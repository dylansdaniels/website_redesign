<html><body>
<div class='markdown-cell'>
	<h1>8.1: From MEG sensor-space data to HNN simulation</h1>
<p>This example demonstrates how to calculate an inverse solution of the
median nerve evoked response potential (ERP) in S1 from the MNE
somatosensory dataset, and then simulate a biophysical model network
that reproduces the observed dynamics. Note that we do not expound on
how we came up with the sequence of evoked drives used in this example,
rather, we only demonstrate its implementation. For those who want more
background on the HNN model and the process used to articulate the
proximal and distal drives needed to simulate evoked responses, see the
<code>HNN ERP tutorial</code>. The sequence of evoked drives presented
here is not part of a current publication but is motivated by prior
studies [1], [2].</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		# Authors: Mainak Jas <mainakjas@gmail.com>
#          Ryan Thorpe <ryan_thorpe@brown.edu>

# sphinx_gallery_thumbnail_number = 2
	</code>
</div>
<div class='markdown-cell'>
	<p>Note: This specific notebook requires the installation of several
other, non-HNN packages in order to run and plot MNE output properly.
The next cell will install these packages into your Python environment
automatically.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		%pip install -q mne nibabel ipyevents "pyvista[all]" pyvistaqt
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		Note: you may need to restart the kernel to use updated packages.

	</div>
</div>
<div class='code-cell'>
	<code class='language-python'>
		# Needed for certain plotting to work
import pyvista as pv
from mne.viz import set_3d_backend
set_3d_backend('notebook')
pv.set_jupyter_backend('client')
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		Using notebook 3d backend.

	</div>
</div>
<div class='markdown-cell'>
	<p>We will import the packages needed for computing the inverse solution
from the MNE somatosensory dataset. <code>MNE</code>, and its dependency
<code>NiBabel</code> should have been installed using the previous
<code>pip</code> command. The somatosensory dataset can be downloaded by
importing <code>somato</code> from <code>mne.datasets</code>.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		import os.path as op
import matplotlib.pyplot as plt

import mne
from mne.datasets import somato
from mne.minimum_norm import apply_inverse, make_inverse_operator
	</code>
</div>
<div class='markdown-cell'>
	<p>Now we set the the path of the <code>somato</code> dataset for
subject <code>&amp;#x27;01&amp;#x27;</code>.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		data_path = somato.data_path()
subject = '01'
task = 'somato'
raw_fname = op.join(data_path, 'sub-{}'.format(subject), 'meg',
                    'sub-{}_task-{}_meg.fif'.format(subject, task))
fwd_fname = op.join(data_path, 'derivatives', 'sub-{}'.format(subject),
                    'sub-{}_task-{}-fwd.fif'.format(subject, task))
subjects_dir = op.join(data_path, 'derivatives', 'freesurfer', 'subjects')
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		Using default location ~/mne_data for somato...

		Creating /home/runner/mne_data

		Attempting to create new mne-python configuration file:
/home/runner/.mne/mne-python.json

		Download complete in 20s (582.2 MB)

	</div>
</div>
<div class='markdown-cell'>
	<p>Then, we load the raw data and estimate the inverse operator.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		# Read and band-pass filter the raw data
raw = mne.io.read_raw_fif(raw_fname, preload=True)
l_freq, h_freq = 1, 40
raw.filter(l_freq, h_freq)

# Identify stimulus events associated with MEG time series in the dataset
events = mne.find_events(raw, stim_channel='STI 014')

# Define epochs within the time series
event_id, tmin, tmax = 1, -.2, .17
baseline = None
epochs = mne.Epochs(raw, events, event_id, tmin, tmax, baseline=baseline,
                    reject=dict(grad=4000e-13, eog=350e-6), preload=True)

# Compute the inverse operator
fwd = mne.read_forward_solution(fwd_fname)
cov = mne.compute_covariance(epochs)
inv = make_inverse_operator(epochs.info, fwd, cov)
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		Opening raw data file /home/runner/mne_data/MNE-somato-data/sub-01/meg/sub-01_task-somato_meg.fif...

		    Range : 237600 ... 506999 =    791.189 ...  1688.266 secs

		Ready.

		Reading 0 ... 269399  =      0.000 ...   897.077 secs...

		Filtering raw data in 1 contiguous segment

		Setting up band-pass filter from 1 - 40 Hz

		

		FIR filter parameters

		---------------------

		Designing a one-pass, zero-phase, non-causal bandpass filter:

		- Windowed time-domain design (firwin) method

		- Hamming window with 0.0194 passband ripple and 53 dB stopband attenuation

		- Lower passband edge: 1.00

		- Lower transition bandwidth: 1.00 Hz (-6 dB cutoff frequency: 0.50 Hz)

		- Upper passband edge: 40.00 Hz

		- Upper transition bandwidth: 10.00 Hz (-6 dB cutoff frequency: 45.00 Hz)

		- Filter length: 993 samples (3.307 s)

		

		111 events found on stim channel STI 014

		Event IDs: [1]

		Not setting metadata

		111 matching events found

		No baseline correction applied

		0 projection items activated

		Using data from preloaded Raw for 111 events and 112 original time points ...

		0 bad epochs dropped

		Reading forward solution from /home/runner/mne_data/MNE-somato-data/derivatives/sub-01/sub-01_task-somato-fwd.fif...

		    Reading a source space...

		    [done]

		    Reading a source space...

		    [done]

		    2 source spaces read

		    Desired named matrix (kind = 3523 (FIFF_MNE_FORWARD_SOLUTION_GRAD)) not available

		    Read MEG forward solution (8155 sources, 306 channels, free orientations)

		    Source spaces transformed to the forward solution coordinate frame

		Reducing data rank from 306 -&gt; 306

		Estimating covariance using EMPIRICAL

		Done.

		Number of samples used : 12432

		[done]

		Converting forward solution to surface orientation

		    No patch info available. The standard source space normals will be employed in the rotation to the local surface coordinates....

		    Converting to surface-based source orientations...

		    [done]

		Computing inverse operator with 306 channels.

		    306 out of 306 channels remain after picking

		Selected 306 channels

		Creating the depth weighting matrix...

		    204 planar channels

		    limit = 7615/8155 = 10.004172

		    scale = 5.17919e-08 exp = 0.8

		Applying loose dipole orientations to surface source spaces: 0.2

		Whitening the forward solution.

		Computing rank from covariance with rank=None

		    Using tolerance 2e-12 (2.2e-16 eps * 306 dim * 29  max singular value)

		    Estimated rank (mag + grad): 64

		    MEG: rank 64 computed from 306 data channels with 0 projectors

		    Setting small MEG eigenvalues to zero (without PCA)

		Creating the source covariance matrix

		Adjusting source covariance matrix.

		Computing SVD of whitened and weighted lead field matrix.

		    largest singular value = 2.42284

		    scaling factor to adjust the trace = 3.86104e+18 (nchan = 306 nzero = 242)

	</div>
</div>
<div class='markdown-cell'>
	<p>There are several methods to do source reconstruction. Some of the
methods such as MNE are distributed source methods whereas dipole
fitting will estimate the location and amplitude of a single current
dipole. At the moment, we do not offer explicit recommendations on which
source reconstruction technique is best for HNN. However, we do want our
users to note that the dipole currents simulated with HNN are assumed to
be normal to the cortical surface. Hence, using the option
<code>pick_ori=&amp;#x27;normal&amp;#x27;</code> is appropriate.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		snr = 3.
lambda2 = 1. / snr ** 2
evoked = epochs.average()
stc = apply_inverse(evoked, inv, lambda2, method='MNE',
                    pick_ori="normal", return_residual=False,
                    verbose=True)
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		Preparing the inverse operator for use...

		    Scaled noise and source covariance from nave = 1 to nave = 111

		    Created the regularized inverter

		    The projection vectors do not apply to these channels.

		    Created the whitener using a noise covariance matrix with rank 64 (242 small eigenvalues omitted)

		Applying inverse operator to &quot;1&quot;...

		    Picked 306 channels from the data

		    Computing inverse...

		    Eigenleads need to be weighted ...

		    Computing residual...

		    Explained  86.1% variance

		[done]

	</div>
</div>
<div class='markdown-cell'>
	<p>To extract the primary response in primary somatosensory cortex (S1),
we create a label for the postcentral gyrus (S1) in source-space</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		hemi = 'rh'
label_tag = 'G_postcentral'
label_s1 = mne.read_labels_from_annot(subject, parc='aparc.a2009s', hemi=hemi,
                                      regexp=label_tag,
                                      subjects_dir=subjects_dir)[0]
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		Reading labels from parcellation...

		   read 1 labels from /home/runner/mne_data/MNE-somato-data/derivatives/freesurfer/subjects/01/label/rh.aparc.a2009s.annot

	</div>
</div>
<div class='markdown-cell'>
	<p>Visualizing the distributed S1 activation in reference to the
geometric structure of the cortex (i.e., plotted on a structural MRI)
can help us figure out how to orient the dipole. Note that in the HNN
framework, positive and negative deflections of a current dipole source
correspond to upwards (from deep to superficial) and downwards (from
superficial to deep) current flow, respectively. Uncomment the following
code to open an interactive 3D render of the brain and its surface
activation (requires the <code>pyvista</code> python library). You
should get 2 plots, the first showing the post-central gyrus label from
which the dipole time course was extracted and the second showing MNE
activation at 0.040 sec that resemble the following images.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		'''
Brain = mne.viz.get_brain_class()
brain_label = Brain(subject, hemi, 'white', subjects_dir=subjects_dir)
brain_label.add_label(label_s1, color='green', alpha=0.9)
stc_label = stc.in_label(label_s1)
brain = stc_label.plot(subjects_dir=subjects_dir, hemi=hemi, surface='white',
                       view_layout='horizontal', initial_time=0.04,
                       backend='pyvista')
'''
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		&quot;\nBrain = mne.viz.get_brain_class()\nbrain_label = Brain(subject, hemi, &#x27;white&#x27;, subjects_dir=subjects_dir)\nbrain_label.add_label(label_s1, color=&#x27;green&#x27;, alpha=0.9)\nstc_label = stc.in_label(label_s1)\nbrain = stc_label.plot(subjects_dir=subjects_dir, hemi=hemi, surface=&#x27;white&#x27;,\n                       view_layout=&#x27;horizontal&#x27;, initial_time=0.04,\n                       backend=&#x27;pyvista&#x27;)\n&quot;
	</div>
</div>
<div class='markdown-cell'>
	<figure>
<img
src="https://user-images.githubusercontent.com/20212206/106524603-cfe75c80-64b0-11eb-9607-3415195c3e7a.png"
alt="mne_label_fig" />
<figcaption aria-hidden="true">mne_label_fig</figcaption>
</figure>

</div>
<div class='markdown-cell'>
	<figure>
<img
src="https://user-images.githubusercontent.com/20212206/106524542-b514e800-64b0-11eb-835e-497454e75eb9.png"
alt="mne_activity_fig" />
<figcaption aria-hidden="true">mne_activity_fig</figcaption>
</figure>

</div>
<div class='markdown-cell'>
	<p>Now we extract the representative time course of dipole activation in
our labeled brain region using
<code>mode=&amp;#x27;pca_flip&amp;#x27;</code> (see
<code>this MNE-python example</code>_ for more details). Note that the
most prominent component of the median nerve response occurs in the
posterior wall of the central sulcus at ~0.040 sec. Since the dipolar
activity here is negative, we orient the extracted waveform so that the
deflection at ~0.040 sec is pointed downwards. Thus, the ~0.040 sec
deflection corresponds to current flow traveling from superficial to
deep layers of cortex.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		flip_data = stc.extract_label_time_course(label_s1, inv['src'],
                                          mode='pca_flip')
dipole_tc = -flip_data[0] * 1e9

plt.figure()
plt.plot(1e3 * stc.times, dipole_tc, 'ro--')
plt.xlabel('Time (ms)')
plt.ylabel('Current Dipole (nAm)')
plt.xlim((0, 170))
plt.axhline(0, c='k', ls=':')
plt.show()
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		Extracting time courses for 1 labels (mode: pca_flip)

		&lt;Figure size 640x480 with 1 Axes&gt;
	</div>
</div>
<div class='output-cell'>
	<img src='output_nb_from_meg_to_hnn_notebook/fig_01.png'/>
</div>
<div class='markdown-cell'>
	<p>Now, let us try to simulate the same with <code>hnn-core</code>. We
read in the network parameters from <code>N20.json</code> and
instantiate the network.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		import hnn_core
from hnn_core import simulate_dipole, jones_2009_model
from hnn_core import average_dipoles, JoblibBackend

hnn_core_root = op.dirname(hnn_core.__file__)
params_fname = op.join(hnn_core_root, 'param', 'N20.json')
net = jones_2009_model(params_fname)
	</code>
</div>
<div class='markdown-cell'>
	<p>To simulate the source of the median nerve evoked response, we add a
sequence of synchronous evoked drives: 1 proximal, 2 distal, and 1 final
proximal drive. In order to understand the physiological implications of
proximal and distal drive as well as the general process used to
articulate a sequence of exogenous drive for simulating evoked
responses, see the <code>HNN ERP tutorial</code>_. Note that setting
<code>n_drive_cells=1</code> and <code>cell_specific=False</code>
creates a drive with synchronous input across cells in the network.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		# Early proximal drive
weights_ampa_p = {'L2_basket': 0.0036, 'L2_pyramidal': 0.0039,
                  'L5_basket': 0.0019, 'L5_pyramidal': 0.0020}
weights_nmda_p = {'L2_basket': 0.0029, 'L2_pyramidal': 0.0005,
                  'L5_basket': 0.0030, 'L5_pyramidal': 0.0019}
synaptic_delays_p = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,
                     'L5_basket': 1.0, 'L5_pyramidal': 1.0}

net.add_evoked_drive(
    'evprox1', mu=21., sigma=4., numspikes=1, location='proximal',
    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_p,
    weights_nmda=weights_nmda_p, synaptic_delays=synaptic_delays_p,
    event_seed=276)

# Late proximal drive
weights_ampa_p = {'L2_basket': 0.003, 'L2_pyramidal': 0.0039,
                  'L5_basket': 0.004, 'L5_pyramidal': 0.0020}
weights_nmda_p = {'L2_basket': 0.001, 'L2_pyramidal': 0.0005,
                  'L5_basket': 0.002, 'L5_pyramidal': 0.0020}
synaptic_delays_p = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,
                     'L5_basket': 1.0, 'L5_pyramidal': 1.0}

net.add_evoked_drive(
    'evprox2', mu=134., sigma=4.5, numspikes=1, location='proximal',
    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_p,
    weights_nmda=weights_nmda_p, synaptic_delays=synaptic_delays_p,
    event_seed=276)

# Early distal drive
weights_ampa_d = {'L2_basket': 0.0043, 'L2_pyramidal': 0.0032,
                  'L5_pyramidal': 0.0009}
weights_nmda_d = {'L2_basket': 0.0029, 'L2_pyramidal': 0.0051,
                  'L5_pyramidal': 0.0010}
synaptic_delays_d = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,
                     'L5_pyramidal': 0.1}

net.add_evoked_drive(
    'evdist1', mu=32., sigma=2.5, numspikes=1, location='distal',
    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_d,
    weights_nmda=weights_nmda_d, synaptic_delays=synaptic_delays_d,
    event_seed=277)

# Late distal drive
weights_ampa_d = {'L2_basket': 0.0041, 'L2_pyramidal': 0.0019,
                  'L5_pyramidal': 0.0018}
weights_nmda_d = {'L2_basket': 0.0032, 'L2_pyramidal': 0.0018,
                  'L5_pyramidal': 0.0017}
synaptic_delays_d = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,
                     'L5_pyramidal': 0.1}

net.add_evoked_drive(
    'evdist2', mu=84., sigma=4.5, numspikes=1, location='distal',
    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_d,
    weights_nmda=weights_nmda_d, synaptic_delays=synaptic_delays_d,
    event_seed=275)
	</code>
</div>
<div class='markdown-cell'>
	<p>Now we run the simulation over 2 trials so that we can plot the
average aggregate dipole. For a better match to the empirical waveform,
set <code>n_trials</code> to be &gt;=25.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		n_trials = 2
# n_trials = 25
with JoblibBackend(n_jobs=2):
    dpls = simulate_dipole(net, tstop=170., n_trials=n_trials)
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		Joblib will run 2 trial(s) in parallel by distributing trials over 2 jobs.

		Loading custom mechanism files from /usr/share/miniconda/envs/website-redesign-mpi/lib/python3.12/site-packages/hnn_core/mod/x86_64/libnrnmech.so
Building the NEURON model
Loading custom mechanism files from /usr/share/miniconda/envs/website-redesign-mpi/lib/python3.12/site-packages/hnn_core/mod/x86_64/libnrnmech.so
Building the NEURON model

		[Done]
[Done]
Trial 2: 0.03 ms...
Trial 1: 0.03 ms...

		Trial 1: 10.0 ms...
Trial 2: 10.0 ms...

		Trial 1: 20.0 ms...
Trial 2: 20.0 ms...

		Trial 1: 30.0 ms...
Trial 2: 30.0 ms...

		Trial 1: 40.0 ms...

		Trial 2: 40.0 ms...

		Trial 1: 50.0 ms...

		Trial 2: 50.0 ms...

		Trial 1: 60.0 ms...

		Trial 2: 60.0 ms...

		Trial 1: 70.0 ms...

		Trial 2: 70.0 ms...

		Trial 1: 80.0 ms...

		Trial 2: 80.0 ms...

		Trial 1: 90.0 ms...

		Trial 2: 90.0 ms...

		Trial 1: 100.0 ms...

		Trial 2: 100.0 ms...

		Trial 1: 110.0 ms...

		Trial 2: 110.0 ms...

		Trial 1: 120.0 ms...

		Trial 2: 120.0 ms...

		Trial 1: 130.0 ms...

		Trial 2: 130.0 ms...

		Trial 1: 140.0 ms...

		Trial 2: 140.0 ms...

		Trial 1: 150.0 ms...

		Trial 2: 150.0 ms...

		Trial 1: 160.0 ms...

		Trial 2: 160.0 ms...

	</div>
</div>
<div class='markdown-cell'>
	<p>Since the model is a reduced representation of the larger network
contributing to the response, the model response is noisier than it
would be in the net activity from a larger network where these effects
are averaged out, and the dipole amplitude is smaller than the recorded
data. The post-processing steps of smoothing and scaling the simulated
dipole response allow us to more accurately approximate the true signal
responsible for the recorded macroscopic evoked response [1]<em>,
[2]</em>.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		dpl_smooth_win = 20
dpl_scalefctr = 12
for dpl in dpls:
    dpl.smooth(dpl_smooth_win)
    dpl.scale(dpl_scalefctr)
	</code>
</div>
<div class='markdown-cell'>
	<p>Finally, we plot the driving spike histogram, empirical and simulated
median nerve evoked response waveforms, and output spike histogram.</p>

</div>
<div class='code-cell'>
	<code class='language-python'>
		fig, axes = plt.subplots(3, 1, sharex=True, figsize=(6, 6),
                         constrained_layout=True)
net.cell_response.plot_spikes_hist(ax=axes[0],
                                   spike_types=['evprox', 'evdist'],
                                   show=False)
axes[1].axhline(0, c='k', ls=':', label='_nolegend_')
axes[1].plot(1e3 * stc.times, dipole_tc, 'r--')
average_dipoles(dpls).plot(ax=axes[1], show=False)
axes[1].legend(['MNE label average', 'HNN simulation'])
axes[1].set_ylabel('Current Dipole (nAm)')
net.cell_response.plot_spikes_raster(ax=axes[2])
	</code>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		&lt;Figure size 600x600 with 3 Axes&gt;
	</div>
</div>
<div class='output-cell'>
	<img src='output_nb_from_meg_to_hnn_notebook/fig_02.png'/>
</div>
<div class='output-cell'><div class='output-label'>
	Out:
</div>
	<div class='output-code'>
		&lt;Figure size 600x600 with 3 Axes&gt;
	</div>
</div>
<div class='output-cell'>
	<img src='output_nb_from_meg_to_hnn_notebook/fig_03.png'/>
</div>
<div class='markdown-cell'>
	<h2>References</h2>
<p>[1] Jones, S. R., Pritchett, D. L., Stufflebeam, S. M., Hämäläinen,
M. &amp; Moore, C. I. Neural correlates of tactile detection: a combined
magnetoencephalography and biophysically based computational modeling
study. J. Neurosci. 27, 10751–10764 (2007).</p>
<p>[2] Neymotin SA, Daniels DS, Caldwell B, McDougal RA, Carnevale NT,
Jas M, Moore CI, Hines ML, Hämäläinen M, Jones SR. Human Neocortical
Neurosolver (HNN), a new software tool for interpreting the cellular and
network origin of human MEG/EEG data. eLife 9, e51214 (2020).
https://doi.org/10.7554/eLife.51214</p>

</div>
</body></html>