{
    "full_executed": true,
    "from_meg_to_hnn_notebook.ipynb": {
        "8.1: From MEG sensor-space data to HNN simulation": {
            "level": 1,
            "html": "<div class='markdown-cell'>\n    <h1>8.1: From MEG sensor-space data to HNN simulation</h1>\n<p>This example demonstrates how to calculate an inverse solution of the\nmedian nerve evoked response potential (ERP) in S1 from the MNE\nsomatosensory dataset, and then simulate a biophysical model network\nthat reproduces the observed dynamics. Note that we do not expound on\nhow we came up with the sequence of evoked drives used in this example,\nrather, we only demonstrate its implementation. For those who want more\nbackground on the HNN model and the process used to articulate the\nproximal and distal drives needed to simulate evoked responses, see the\n<code>HNN ERP tutorial</code>. The sequence of evoked drives presented\nhere is not part of a current publication but is motivated by prior\nstudies [1], [2].</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Authors: Mainak Jas <mainakjas@gmail.com>\n#          Ryan Thorpe <ryan_thorpe@brown.edu>\n\n# sphinx_gallery_thumbnail_number = 2\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Note: This specific notebook requires the installation of several\nother, non-HNN packages in order to run and plot MNE output properly.\nThe next cell will install these packages into your Python environment\nautomatically.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        %pip install -q mne nibabel ipyevents \"pyvista[all]\" pyvistaqt\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Note: you may need to restart the kernel to use updated packages.\n\n    </div>\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Needed for certain plotting to work\nimport pyvista as pv\nfrom mne.viz import set_3d_backend\nset_3d_backend('notebook')\npv.set_jupyter_backend('client')\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Using notebook 3d backend.\n\n    </div>\n</div>\n<div class='markdown-cell'>\n    <p>We will import the packages needed for computing the inverse solution\nfrom the MNE somatosensory dataset. <code>MNE</code>, and its dependency\n<code>NiBabel</code> should have been installed using the previous\n<code>pip</code> command. The somatosensory dataset can be downloaded by\nimporting <code>somato</code> from <code>mne.datasets</code>.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        import os.path as op\nimport matplotlib.pyplot as plt\n\nimport mne\nfrom mne.datasets import somato\nfrom mne.minimum_norm import apply_inverse, make_inverse_operator\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Now we set the the path of the <code>somato</code> dataset for\nsubject <code>&amp;#x27;01&amp;#x27;</code>.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        data_path = somato.data_path()\nsubject = '01'\ntask = 'somato'\nraw_fname = op.join(data_path, 'sub-{}'.format(subject), 'meg',\n                    'sub-{}_task-{}_meg.fif'.format(subject, task))\nfwd_fname = op.join(data_path, 'derivatives', 'sub-{}'.format(subject),\n                    'sub-{}_task-{}-fwd.fif'.format(subject, task))\nsubjects_dir = op.join(data_path, 'derivatives', 'freesurfer', 'subjects')\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Using default location ~/mne_data for somato...\n\n        Creating /home/runner/mne_data\n\n        Attempting to create new mne-python configuration file:\n/home/runner/.mne/mne-python.json\n\n        Download complete in 30s (582.2 MB)\n\n    </div>\n</div>\n<div class='markdown-cell'>\n    <p>Then, we load the raw data and estimate the inverse operator.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Read and band-pass filter the raw data\nraw = mne.io.read_raw_fif(raw_fname, preload=True)\nl_freq, h_freq = 1, 40\nraw.filter(l_freq, h_freq)\n\n# Identify stimulus events associated with MEG time series in the dataset\nevents = mne.find_events(raw, stim_channel='STI 014')\n\n# Define epochs within the time series\nevent_id, tmin, tmax = 1, -.2, .17\nbaseline = None\nepochs = mne.Epochs(raw, events, event_id, tmin, tmax, baseline=baseline,\n                    reject=dict(grad=4000e-13, eog=350e-6), preload=True)\n\n# Compute the inverse operator\nfwd = mne.read_forward_solution(fwd_fname)\ncov = mne.compute_covariance(epochs)\ninv = make_inverse_operator(epochs.info, fwd, cov)\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Opening raw data file /home/runner/mne_data/MNE-somato-data/sub-01/meg/sub-01_task-somato_meg.fif...\n\n            Range : 237600 ... 506999 =    791.189 ...  1688.266 secs\n\n        Ready.\n\n        Reading 0 ... 269399  =      0.000 ...   897.077 secs...\n\n        Filtering raw data in 1 contiguous segment\n\n        Setting up band-pass filter from 1 - 40 Hz\n\n        \n\n        FIR filter parameters\n\n        ---------------------\n\n        Designing a one-pass, zero-phase, non-causal bandpass filter:\n\n        - Windowed time-domain design (firwin) method\n\n        - Hamming window with 0.0194 passband ripple and 53 dB stopband attenuation\n\n        - Lower passband edge: 1.00\n\n        - Lower transition bandwidth: 1.00 Hz (-6 dB cutoff frequency: 0.50 Hz)\n\n        - Upper passband edge: 40.00 Hz\n\n        - Upper transition bandwidth: 10.00 Hz (-6 dB cutoff frequency: 45.00 Hz)\n\n        - Filter length: 993 samples (3.307 s)\n\n        \n\n        111 events found on stim channel STI 014\n\n        Event IDs: [1]\n\n        Not setting metadata\n\n        111 matching events found\n\n        No baseline correction applied\n\n        0 projection items activated\n\n        Using data from preloaded Raw for 111 events and 112 original time points ...\n\n        0 bad epochs dropped\n\n        Reading forward solution from /home/runner/mne_data/MNE-somato-data/derivatives/sub-01/sub-01_task-somato-fwd.fif...\n\n            Reading a source space...\n\n            [done]\n\n            Reading a source space...\n\n            [done]\n\n            2 source spaces read\n\n            Desired named matrix (kind = 3523 (FIFF_MNE_FORWARD_SOLUTION_GRAD)) not available\n\n            Read MEG forward solution (8155 sources, 306 channels, free orientations)\n\n            Source spaces transformed to the forward solution coordinate frame\n\n        Reducing data rank from 306 -&gt; 306\n\n        Estimating covariance using EMPIRICAL\n\n        Done.\n\n        Number of samples used : 12432\n\n        [done]\n\n        Converting forward solution to surface orientation\n\n            No patch info available. The standard source space normals will be employed in the rotation to the local surface coordinates....\n\n            Converting to surface-based source orientations...\n\n            [done]\n\n        Computing inverse operator with 306 channels.\n\n            306 out of 306 channels remain after picking\n\n        Selected 306 channels\n\n        Creating the depth weighting matrix...\n\n            204 planar channels\n\n            limit = 7615/8155 = 10.004172\n\n            scale = 5.17919e-08 exp = 0.8\n\n        Applying loose dipole orientations to surface source spaces: 0.2\n\n        Whitening the forward solution.\n\n        Computing rank from covariance with rank=None\n\n            Using tolerance 2e-12 (2.2e-16 eps * 306 dim * 29  max singular value)\n\n            Estimated rank (mag + grad): 64\n\n            MEG: rank 64 computed from 306 data channels with 0 projectors\n\n            Setting small MEG eigenvalues to zero (without PCA)\n\n        Creating the source covariance matrix\n\n        Adjusting source covariance matrix.\n\n        Computing SVD of whitened and weighted lead field matrix.\n\n            largest singular value = 2.42284\n\n            scaling factor to adjust the trace = 3.86104e+18 (nchan = 306 nzero = 242)\n\n    </div>\n</div>\n<div class='markdown-cell'>\n    <p>There are several methods to do source reconstruction. Some of the\nmethods such as MNE are distributed source methods whereas dipole\nfitting will estimate the location and amplitude of a single current\ndipole. At the moment, we do not offer explicit recommendations on which\nsource reconstruction technique is best for HNN. However, we do want our\nusers to note that the dipole currents simulated with HNN are assumed to\nbe normal to the cortical surface. Hence, using the option\n<code>pick_ori=&amp;#x27;normal&amp;#x27;</code> is appropriate.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        snr = 3.\nlambda2 = 1. / snr ** 2\nevoked = epochs.average()\nstc = apply_inverse(evoked, inv, lambda2, method='MNE',\n                    pick_ori=\"normal\", return_residual=False,\n                    verbose=True)\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Preparing the inverse operator for use...\n\n            Scaled noise and source covariance from nave = 1 to nave = 111\n\n            Created the regularized inverter\n\n            The projection vectors do not apply to these channels.\n\n            Created the whitener using a noise covariance matrix with rank 64 (242 small eigenvalues omitted)\n\n        Applying inverse operator to &quot;1&quot;...\n\n            Picked 306 channels from the data\n\n            Computing inverse...\n\n            Eigenleads need to be weighted ...\n\n            Computing residual...\n\n            Explained  86.1% variance\n\n        [done]\n\n    </div>\n</div>\n<div class='markdown-cell'>\n    <p>To extract the primary response in primary somatosensory cortex (S1),\nwe create a label for the postcentral gyrus (S1) in source-space</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        hemi = 'rh'\nlabel_tag = 'G_postcentral'\nlabel_s1 = mne.read_labels_from_annot(subject, parc='aparc.a2009s', hemi=hemi,\n                                      regexp=label_tag,\n                                      subjects_dir=subjects_dir)[0]\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Reading labels from parcellation...\n\n           read 1 labels from /home/runner/mne_data/MNE-somato-data/derivatives/freesurfer/subjects/01/label/rh.aparc.a2009s.annot\n\n    </div>\n</div>\n<div class='markdown-cell'>\n    <p>Visualizing the distributed S1 activation in reference to the\ngeometric structure of the cortex (i.e., plotted on a structural MRI)\ncan help us figure out how to orient the dipole. Note that in the HNN\nframework, positive and negative deflections of a current dipole source\ncorrespond to upwards (from deep to superficial) and downwards (from\nsuperficial to deep) current flow, respectively. Uncomment the following\ncode to open an interactive 3D render of the brain and its surface\nactivation (requires the <code>pyvista</code> python library). You\nshould get 2 plots, the first showing the post-central gyrus label from\nwhich the dipole time course was extracted and the second showing MNE\nactivation at 0.040 sec that resemble the following images.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        '''\nBrain = mne.viz.get_brain_class()\nbrain_label = Brain(subject, hemi, 'white', subjects_dir=subjects_dir)\nbrain_label.add_label(label_s1, color='green', alpha=0.9)\nstc_label = stc.in_label(label_s1)\nbrain = stc_label.plot(subjects_dir=subjects_dir, hemi=hemi, surface='white',\n                       view_layout='horizontal', initial_time=0.04,\n                       backend='pyvista')\n'''\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        &quot;\\nBrain = mne.viz.get_brain_class()\\nbrain_label = Brain(subject, hemi, &#x27;white&#x27;, subjects_dir=subjects_dir)\\nbrain_label.add_label(label_s1, color=&#x27;green&#x27;, alpha=0.9)\\nstc_label = stc.in_label(label_s1)\\nbrain = stc_label.plot(subjects_dir=subjects_dir, hemi=hemi, surface=&#x27;white&#x27;,\\n                       view_layout=&#x27;horizontal&#x27;, initial_time=0.04,\\n                       backend=&#x27;pyvista&#x27;)\\n&quot;\n    </div>\n</div>\n<div class='markdown-cell'>\n    <figure>\n<img\nsrc=\"https://user-images.githubusercontent.com/20212206/106524603-cfe75c80-64b0-11eb-9607-3415195c3e7a.png\"\nalt=\"mne_label_fig\" />\n<figcaption aria-hidden=\"true\">mne_label_fig</figcaption>\n</figure>\n\n</div>\n<div class='markdown-cell'>\n    <figure>\n<img\nsrc=\"https://user-images.githubusercontent.com/20212206/106524542-b514e800-64b0-11eb-835e-497454e75eb9.png\"\nalt=\"mne_activity_fig\" />\n<figcaption aria-hidden=\"true\">mne_activity_fig</figcaption>\n</figure>\n\n</div>\n<div class='markdown-cell'>\n    <p>Now we extract the representative time course of dipole activation in\nour labeled brain region using\n<code>mode=&amp;#x27;pca_flip&amp;#x27;</code> (see\n<code>this MNE-python example</code>_ for more details). Note that the\nmost prominent component of the median nerve response occurs in the\nposterior wall of the central sulcus at ~0.040 sec.\u00a0Since the dipolar\nactivity here is negative, we orient the extracted waveform so that the\ndeflection at ~0.040 sec is pointed downwards. Thus, the ~0.040 sec\ndeflection corresponds to current flow traveling from superficial to\ndeep layers of cortex.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        flip_data = stc.extract_label_time_course(label_s1, inv['src'],\n                                          mode='pca_flip')\ndipole_tc = -flip_data[0] * 1e9\n\nplt.figure()\nplt.plot(1e3 * stc.times, dipole_tc, 'ro--')\nplt.xlabel('Time (ms)')\nplt.ylabel('Current Dipole (nAm)')\nplt.xlim((0, 170))\nplt.axhline(0, c='k', ls=':')\nplt.show()\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Extracting time courses for 1 labels (mode: pca_flip)\n\n        &lt;Figure size 640x480 with 1 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_from_meg_to_hnn_notebook/fig_01.png'/>\n</div>\n<div class='markdown-cell'>\n    <p>Now, let us try to simulate the same with <code>hnn-core</code>. We\nread in the network parameters from <code>N20.json</code> and\ninstantiate the network.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        import hnn_core\nfrom hnn_core import simulate_dipole, jones_2009_model\nfrom hnn_core import average_dipoles, JoblibBackend\n\nhnn_core_root = op.dirname(hnn_core.__file__)\nparams_fname = op.join(hnn_core_root, 'param', 'N20.json')\nnet = jones_2009_model(params_fname)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>To simulate the source of the median nerve evoked response, we add a\nsequence of synchronous evoked drives: 1 proximal, 2 distal, and 1 final\nproximal drive. In order to understand the physiological implications of\nproximal and distal drive as well as the general process used to\narticulate a sequence of exogenous drive for simulating evoked\nresponses, see the <code>HNN ERP tutorial</code>_. Note that setting\n<code>n_drive_cells=1</code> and <code>cell_specific=False</code>\ncreates a drive with synchronous input across cells in the network.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Early proximal drive\nweights_ampa_p = {'L2_basket': 0.0036, 'L2_pyramidal': 0.0039,\n                  'L5_basket': 0.0019, 'L5_pyramidal': 0.0020}\nweights_nmda_p = {'L2_basket': 0.0029, 'L2_pyramidal': 0.0005,\n                  'L5_basket': 0.0030, 'L5_pyramidal': 0.0019}\nsynaptic_delays_p = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,\n                     'L5_basket': 1.0, 'L5_pyramidal': 1.0}\n\nnet.add_evoked_drive(\n    'evprox1', mu=21., sigma=4., numspikes=1, location='proximal',\n    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_p,\n    weights_nmda=weights_nmda_p, synaptic_delays=synaptic_delays_p,\n    event_seed=276)\n\n# Late proximal drive\nweights_ampa_p = {'L2_basket': 0.003, 'L2_pyramidal': 0.0039,\n                  'L5_basket': 0.004, 'L5_pyramidal': 0.0020}\nweights_nmda_p = {'L2_basket': 0.001, 'L2_pyramidal': 0.0005,\n                  'L5_basket': 0.002, 'L5_pyramidal': 0.0020}\nsynaptic_delays_p = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,\n                     'L5_basket': 1.0, 'L5_pyramidal': 1.0}\n\nnet.add_evoked_drive(\n    'evprox2', mu=134., sigma=4.5, numspikes=1, location='proximal',\n    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_p,\n    weights_nmda=weights_nmda_p, synaptic_delays=synaptic_delays_p,\n    event_seed=276)\n\n# Early distal drive\nweights_ampa_d = {'L2_basket': 0.0043, 'L2_pyramidal': 0.0032,\n                  'L5_pyramidal': 0.0009}\nweights_nmda_d = {'L2_basket': 0.0029, 'L2_pyramidal': 0.0051,\n                  'L5_pyramidal': 0.0010}\nsynaptic_delays_d = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,\n                     'L5_pyramidal': 0.1}\n\nnet.add_evoked_drive(\n    'evdist1', mu=32., sigma=2.5, numspikes=1, location='distal',\n    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_d,\n    weights_nmda=weights_nmda_d, synaptic_delays=synaptic_delays_d,\n    event_seed=277)\n\n# Late distal drive\nweights_ampa_d = {'L2_basket': 0.0041, 'L2_pyramidal': 0.0019,\n                  'L5_pyramidal': 0.0018}\nweights_nmda_d = {'L2_basket': 0.0032, 'L2_pyramidal': 0.0018,\n                  'L5_pyramidal': 0.0017}\nsynaptic_delays_d = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,\n                     'L5_pyramidal': 0.1}\n\nnet.add_evoked_drive(\n    'evdist2', mu=84., sigma=4.5, numspikes=1, location='distal',\n    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_d,\n    weights_nmda=weights_nmda_d, synaptic_delays=synaptic_delays_d,\n    event_seed=275)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Now we run the simulation over 2 trials so that we can plot the\naverage aggregate dipole. For a better match to the empirical waveform,\nset <code>n_trials</code> to be &gt;=25.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        n_trials = 2\n# n_trials = 25\nwith JoblibBackend(n_jobs=2):\n    dpls = simulate_dipole(net, tstop=170., n_trials=n_trials)\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Joblib will run 2 trial(s) in parallel by distributing trials over 2 jobs.\n\n        Loading custom mechanism files from /usr/share/miniconda/envs/website-redesign-mpi/lib/python3.12/site-packages/hnn_core/mod/x86_64/libnrnmech.so\nBuilding the NEURON model\nLoading custom mechanism files from /usr/share/miniconda/envs/website-redesign-mpi/lib/python3.12/site-packages/hnn_core/mod/x86_64/libnrnmech.so\nBuilding the NEURON model\n\n        [Done]\n[Done]\nTrial 2: 0.03 ms...\nTrial 1: 0.03 ms...\n\n        Trial 2: 10.0 ms...\nTrial 1: 10.0 ms...\n\n        Trial 2: 20.0 ms...\n\n        Trial 1: 20.0 ms...\n\n        Trial 2: 30.0 ms...\n\n        Trial 1: 30.0 ms...\n\n        Trial 2: 40.0 ms...\n\n        Trial 1: 40.0 ms...\n\n        Trial 2: 50.0 ms...\n\n        Trial 1: 50.0 ms...\n\n        Trial 2: 60.0 ms...\n\n        Trial 1: 60.0 ms...\n\n        Trial 2: 70.0 ms...\n\n        Trial 1: 70.0 ms...\n\n        Trial 2: 80.0 ms...\n\n        Trial 1: 80.0 ms...\n\n        Trial 2: 90.0 ms...\n\n        Trial 1: 90.0 ms...\n\n        Trial 2: 100.0 ms...\n\n        Trial 1: 100.0 ms...\n\n        Trial 2: 110.0 ms...\n\n        Trial 1: 110.0 ms...\n\n        Trial 2: 120.0 ms...\n\n        Trial 1: 120.0 ms...\nTrial 2: 130.0 ms...\n\n        Trial 2: 140.0 ms...\nTrial 1: 130.0 ms...\n\n        Trial 2: 150.0 ms...\nTrial 1: 140.0 ms...\n\n        Trial 2: 160.0 ms...\n\n        Trial 1: 150.0 ms...\n\n        Trial 1: 160.0 ms...\n\n    </div>\n</div>\n<div class='markdown-cell'>\n    <p>Since the model is a reduced representation of the larger network\ncontributing to the response, the model response is noisier than it\nwould be in the net activity from a larger network where these effects\nare averaged out, and the dipole amplitude is smaller than the recorded\ndata. The post-processing steps of smoothing and scaling the simulated\ndipole response allow us to more accurately approximate the true signal\nresponsible for the recorded macroscopic evoked response [1]<em>,\n[2]</em>.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        dpl_smooth_win = 20\ndpl_scalefctr = 12\nfor dpl in dpls:\n    dpl.smooth(dpl_smooth_win)\n    dpl.scale(dpl_scalefctr)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Finally, we plot the driving spike histogram, empirical and simulated\nmedian nerve evoked response waveforms, and output spike histogram.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        fig, axes = plt.subplots(3, 1, sharex=True, figsize=(6, 6),\n                         constrained_layout=True)\nnet.cell_response.plot_spikes_hist(ax=axes[0],\n                                   spike_types=['evprox', 'evdist'],\n                                   show=False)\naxes[1].axhline(0, c='k', ls=':', label='_nolegend_')\naxes[1].plot(1e3 * stc.times, dipole_tc, 'r--')\naverage_dipoles(dpls).plot(ax=axes[1], show=False)\naxes[1].legend(['MNE label average', 'HNN simulation'])\naxes[1].set_ylabel('Current Dipole (nAm)')\nnet.cell_response.plot_spikes_raster(ax=axes[2])\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        &lt;Figure size 600x600 with 3 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_from_meg_to_hnn_notebook/fig_02.png'/>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        &lt;Figure size 600x600 with 3 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_from_meg_to_hnn_notebook/fig_03.png'/>\n</div>"
        },
        "References": {
            "level": 2,
            "html": "<div class='markdown-cell'>\n    <h2>References</h2>\n<p>[1] Jones, S. R., Pritchett, D. L., Stufflebeam, S. M., H\u00e4m\u00e4l\u00e4inen,\nM. &amp; Moore, C. I. Neural correlates of tactile detection: a combined\nmagnetoencephalography and biophysically based computational modeling\nstudy. J. Neurosci. 27, 10751\u201310764 (2007).</p>\n<p>[2] Neymotin SA, Daniels DS, Caldwell B, McDougal RA, Carnevale NT,\nJas M, Moore CI, Hines ML, H\u00e4m\u00e4l\u00e4inen M, Jones SR. Human Neocortical\nNeurosolver (HNN), a new software tool for interpreting the cellular and\nnetwork origin of human MEG/EEG data. eLife 9, e51214 (2020).\nhttps://doi.org/10.7554/eLife.51214</p>\n\n</div>"
        }
    }
}