{
    "full_executed": false,
    "from_meg_to_hnn_notebook.ipynb": {
        "6.1: From MEG sensor-space data to HNN simulation": {
            "level": 1,
            "html": "<div class='markdown-cell'>\n    <h1>6.1: From MEG sensor-space data to HNN simulation</h1>\n<p>This example demonstrates how to calculate an inverse solution of the\nmedian nerve evoked response potential (ERP) in S1 from the MNE\nsomatosensory dataset, and then simulate a biophysical model network\nthat reproduces the observed dynamics. Note that we do not expound on\nhow we came up with the sequence of evoked drives used in this example,\nrather, we only demonstrate its implementation. For those who want more\nbackground on the HNN model and the process used to articulate the\nproximal and distal drives needed to simulate evoked responses, see the\n<code>HNN ERP tutorial</code>. The sequence of evoked drives presented\nhere is not part of a current publication but is motivated by prior\nstudies [1], [2].</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Authors: Mainak Jas <mainakjas@gmail.com>\n#          Ryan Thorpe <ryan_thorpe@brown.edu>\n\n# sphinx_gallery_thumbnail_number = 2\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Note: This specific notebook requires the installation of several\nother, non-HNN packages in order to run and plot MNE output properly.\nThe next cell will install these packages into your Python environment\nautomatically.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        %pip install -q mne nibabel ipyevents \"pyvista[all]\" pyvistaqt\n    </code>\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Needed for certain plotting to work\nimport pyvista as pv\nfrom mne.viz import set_3d_backend\nset_3d_backend('notebook')\npv.set_jupyter_backend('client')\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>We will import the packages needed for computing the inverse solution\nfrom the MNE somatosensory dataset. <code>MNE</code>, and its dependency\n<code>NiBabel</code> should have been installed using the previous\n<code>pip</code> command. The somatosensory dataset can be downloaded by\nimporting <code>somato</code> from <code>mne.datasets</code>.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        import os.path as op\nimport matplotlib.pyplot as plt\n\nimport mne\nfrom mne.datasets import somato\nfrom mne.minimum_norm import apply_inverse, make_inverse_operator\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Now we set the the path of the <code>somato</code> dataset for\nsubject <code>&amp;#x27;01&amp;#x27;</code>.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        data_path = somato.data_path()\nsubject = '01'\ntask = 'somato'\nraw_fname = op.join(data_path, 'sub-{}'.format(subject), 'meg',\n                    'sub-{}_task-{}_meg.fif'.format(subject, task))\nfwd_fname = op.join(data_path, 'derivatives', 'sub-{}'.format(subject),\n                    'sub-{}_task-{}-fwd.fif'.format(subject, task))\nsubjects_dir = op.join(data_path, 'derivatives', 'freesurfer', 'subjects')\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Then, we load the raw data and estimate the inverse operator.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Read and band-pass filter the raw data\nraw = mne.io.read_raw_fif(raw_fname, preload=True)\nl_freq, h_freq = 1, 40\nraw.filter(l_freq, h_freq)\n\n# Identify stimulus events associated with MEG time series in the dataset\nevents = mne.find_events(raw, stim_channel='STI 014')\n\n# Define epochs within the time series\nevent_id, tmin, tmax = 1, -.2, .17\nbaseline = None\nepochs = mne.Epochs(raw, events, event_id, tmin, tmax, baseline=baseline,\n                    reject=dict(grad=4000e-13, eog=350e-6), preload=True)\n\n# Compute the inverse operator\nfwd = mne.read_forward_solution(fwd_fname)\ncov = mne.compute_covariance(epochs)\ninv = make_inverse_operator(epochs.info, fwd, cov)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>There are several methods to do source reconstruction. Some of the\nmethods such as MNE are distributed source methods whereas dipole\nfitting will estimate the location and amplitude of a single current\ndipole. At the moment, we do not offer explicit recommendations on which\nsource reconstruction technique is best for HNN. However, we do want our\nusers to note that the dipole currents simulated with HNN are assumed to\nbe normal to the cortical surface. Hence, using the option\n<code>pick_ori=&amp;#x27;normal&amp;#x27;</code> is appropriate.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        snr = 3.\nlambda2 = 1. / snr ** 2\nevoked = epochs.average()\nstc = apply_inverse(evoked, inv, lambda2, method='MNE',\n                    pick_ori=\"normal\", return_residual=False,\n                    verbose=True)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>To extract the primary response in primary somatosensory cortex (S1),\nwe create a label for the postcentral gyrus (S1) in source-space</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        hemi = 'rh'\nlabel_tag = 'G_postcentral'\nlabel_s1 = mne.read_labels_from_annot(subject, parc='aparc.a2009s', hemi=hemi,\n                                      regexp=label_tag,\n                                      subjects_dir=subjects_dir)[0]\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Visualizing the distributed S1 activation in reference to the\ngeometric structure of the cortex (i.e., plotted on a structural MRI)\ncan help us figure out how to orient the dipole. Note that in the HNN\nframework, positive and negative deflections of a current dipole source\ncorrespond to upwards (from deep to superficial) and downwards (from\nsuperficial to deep) current flow, respectively. Uncomment the following\ncode to open an interactive 3D render of the brain and its surface\nactivation (requires the <code>pyvista</code> python library). You\nshould get 2 plots, the first showing the post-central gyrus label from\nwhich the dipole time course was extracted and the second showing MNE\nactivation at 0.040 sec that resemble the following images.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        '''\nBrain = mne.viz.get_brain_class()\nbrain_label = Brain(subject, hemi, 'white', subjects_dir=subjects_dir)\nbrain_label.add_label(label_s1, color='green', alpha=0.9)\nstc_label = stc.in_label(label_s1)\nbrain = stc_label.plot(subjects_dir=subjects_dir, hemi=hemi, surface='white',\n                       view_layout='horizontal', initial_time=0.04,\n                       backend='pyvista')\n'''\n    </code>\n</div>\n<div class='markdown-cell'>\n    <figure>\n<img\nsrc=\"https://user-images.githubusercontent.com/20212206/106524603-cfe75c80-64b0-11eb-9607-3415195c3e7a.png\"\nalt=\"mne_label_fig\" />\n<figcaption aria-hidden=\"true\">mne_label_fig</figcaption>\n</figure>\n\n</div>\n<div class='markdown-cell'>\n    <figure>\n<img\nsrc=\"https://user-images.githubusercontent.com/20212206/106524542-b514e800-64b0-11eb-835e-497454e75eb9.png\"\nalt=\"mne_activity_fig\" />\n<figcaption aria-hidden=\"true\">mne_activity_fig</figcaption>\n</figure>\n\n</div>\n<div class='markdown-cell'>\n    <p>Now we extract the representative time course of dipole activation in\nour labeled brain region using\n<code>mode=&amp;#x27;pca_flip&amp;#x27;</code> (see\n<code>this MNE-python example</code>_ for more details). Note that the\nmost prominent component of the median nerve response occurs in the\nposterior wall of the central sulcus at ~0.040 sec.\u00a0Since the dipolar\nactivity here is negative, we orient the extracted waveform so that the\ndeflection at ~0.040 sec is pointed downwards. Thus, the ~0.040 sec\ndeflection corresponds to current flow traveling from superficial to\ndeep layers of cortex.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        flip_data = stc.extract_label_time_course(label_s1, inv['src'],\n                                          mode='pca_flip')\ndipole_tc = -flip_data[0] * 1e9\n\nplt.figure()\nplt.plot(1e3 * stc.times, dipole_tc, 'ro--')\nplt.xlabel('Time (ms)')\nplt.ylabel('Current Dipole (nAm)')\nplt.xlim((0, 170))\nplt.axhline(0, c='k', ls=':')\nplt.show()\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Now, let us try to simulate the same with <code>hnn-core</code>. We\nread in the network parameters from <code>N20.json</code> and\ninstantiate the network.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        import hnn_core\nfrom hnn_core import simulate_dipole, jones_2009_model\nfrom hnn_core import average_dipoles, JoblibBackend\n\nhnn_core_root = op.dirname(hnn_core.__file__)\nparams_fname = op.join(hnn_core_root, 'param', 'N20.json')\nnet = jones_2009_model(params_fname)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>To simulate the source of the median nerve evoked response, we add a\nsequence of synchronous evoked drives: 1 proximal, 2 distal, and 1 final\nproximal drive. In order to understand the physiological implications of\nproximal and distal drive as well as the general process used to\narticulate a sequence of exogenous drive for simulating evoked\nresponses, see the <code>HNN ERP tutorial</code>_. Note that setting\n<code>n_drive_cells=1</code> and <code>cell_specific=False</code>\ncreates a drive with synchronous input across cells in the network.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Early proximal drive\nweights_ampa_p = {'L2_basket': 0.0036, 'L2_pyramidal': 0.0039,\n                  'L5_basket': 0.0019, 'L5_pyramidal': 0.0020}\nweights_nmda_p = {'L2_basket': 0.0029, 'L2_pyramidal': 0.0005,\n                  'L5_basket': 0.0030, 'L5_pyramidal': 0.0019}\nsynaptic_delays_p = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,\n                     'L5_basket': 1.0, 'L5_pyramidal': 1.0}\n\nnet.add_evoked_drive(\n    'evprox1', mu=21., sigma=4., numspikes=1, location='proximal',\n    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_p,\n    weights_nmda=weights_nmda_p, synaptic_delays=synaptic_delays_p,\n    event_seed=276)\n\n# Late proximal drive\nweights_ampa_p = {'L2_basket': 0.003, 'L2_pyramidal': 0.0039,\n                  'L5_basket': 0.004, 'L5_pyramidal': 0.0020}\nweights_nmda_p = {'L2_basket': 0.001, 'L2_pyramidal': 0.0005,\n                  'L5_basket': 0.002, 'L5_pyramidal': 0.0020}\nsynaptic_delays_p = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,\n                     'L5_basket': 1.0, 'L5_pyramidal': 1.0}\n\nnet.add_evoked_drive(\n    'evprox2', mu=134., sigma=4.5, numspikes=1, location='proximal',\n    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_p,\n    weights_nmda=weights_nmda_p, synaptic_delays=synaptic_delays_p,\n    event_seed=276)\n\n# Early distal drive\nweights_ampa_d = {'L2_basket': 0.0043, 'L2_pyramidal': 0.0032,\n                  'L5_pyramidal': 0.0009}\nweights_nmda_d = {'L2_basket': 0.0029, 'L2_pyramidal': 0.0051,\n                  'L5_pyramidal': 0.0010}\nsynaptic_delays_d = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,\n                     'L5_pyramidal': 0.1}\n\nnet.add_evoked_drive(\n    'evdist1', mu=32., sigma=2.5, numspikes=1, location='distal',\n    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_d,\n    weights_nmda=weights_nmda_d, synaptic_delays=synaptic_delays_d,\n    event_seed=277)\n\n# Late distal drive\nweights_ampa_d = {'L2_basket': 0.0041, 'L2_pyramidal': 0.0019,\n                  'L5_pyramidal': 0.0018}\nweights_nmda_d = {'L2_basket': 0.0032, 'L2_pyramidal': 0.0018,\n                  'L5_pyramidal': 0.0017}\nsynaptic_delays_d = {'L2_basket': 0.1, 'L2_pyramidal': 0.1,\n                     'L5_pyramidal': 0.1}\n\nnet.add_evoked_drive(\n    'evdist2', mu=84., sigma=4.5, numspikes=1, location='distal',\n    n_drive_cells=1, cell_specific=False, weights_ampa=weights_ampa_d,\n    weights_nmda=weights_nmda_d, synaptic_delays=synaptic_delays_d,\n    event_seed=275)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Now we run the simulation over 2 trials so that we can plot the\naverage aggregate dipole. For a better match to the empirical waveform,\nset <code>n_trials</code> to be &gt;=25.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        n_trials = 2\n# n_trials = 25\nwith JoblibBackend(n_jobs=2):\n    dpls = simulate_dipole(net, tstop=170., n_trials=n_trials)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Since the model is a reduced representation of the larger network\ncontributing to the response, the model response is noisier than it\nwould be in the net activity from a larger network where these effects\nare averaged out, and the dipole amplitude is smaller than the recorded\ndata. The post-processing steps of smoothing and scaling the simulated\ndipole response allow us to more accurately approximate the true signal\nresponsible for the recorded macroscopic evoked response [1]<em>,\n[2]</em>.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        dpl_smooth_win = 20\ndpl_scalefctr = 12\nfor dpl in dpls:\n    dpl.smooth(dpl_smooth_win)\n    dpl.scale(dpl_scalefctr)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Finally, we plot the driving spike histogram, empirical and simulated\nmedian nerve evoked response waveforms, and output spike histogram.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        fig, axes = plt.subplots(3, 1, sharex=True, figsize=(6, 6),\n                         constrained_layout=True)\nnet.cell_response.plot_spikes_hist(ax=axes[0],\n                                   spike_types=['evprox', 'evdist'],\n                                   show=False)\naxes[1].axhline(0, c='k', ls=':', label='_nolegend_')\naxes[1].plot(1e3 * stc.times, dipole_tc, 'r--')\naverage_dipoles(dpls).plot(ax=axes[1], show=False)\naxes[1].legend(['MNE label average', 'HNN simulation'])\naxes[1].set_ylabel('Current Dipole (nAm)')\nnet.cell_response.plot_spikes_raster(ax=axes[2])\n    </code>\n</div>"
        },
        "References": {
            "level": 2,
            "html": "<div class='markdown-cell'>\n    <h2>References</h2>\n<p>[1] Jones, S. R., Pritchett, D. L., Stufflebeam, S. M., H\u00e4m\u00e4l\u00e4inen,\nM. &amp; Moore, C. I. Neural correlates of tactile detection: a combined\nmagnetoencephalography and biophysically based computational modeling\nstudy. J. Neurosci. 27, 10751\u201310764 (2007).</p>\n<p>[2] Neymotin SA, Daniels DS, Caldwell B, McDougal RA, Carnevale NT,\nJas M, Moore CI, Hines ML, H\u00e4m\u00e4l\u00e4inen M, Jones SR. Human Neocortical\nNeurosolver (HNN), a new software tool for interpreting the cellular and\nnetwork origin of human MEG/EEG data. eLife 9, e51214 (2020).\nhttps://doi.org/10.7554/eLife.51214</p>\n\n</div>"
        }
    }
}