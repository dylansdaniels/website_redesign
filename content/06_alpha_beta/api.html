<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HNN Textbook</title>
    <!-- <base href="/website_redesign/"> -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../assets/styles.css">
</head>
<body>

	<div id="mySidebar" class="sidebar">
		<div class="navbar-header">
		<a>
			Human Neocortical Neurosolver
		</a>
		<br>
			<svg class="collapse-icon" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
				<path d="M9 9H4v1h5V9z"/>
				<path fill-rule="evenodd" clip-rule="evenodd" d="M5 3l1-1h7l1 1v7l-1 1h-2v2l-1 1H3l-1-1V6l1-1h2V3zm1 2h4l1 1v4h2V3H6v2zm4 1H3v7h7V6z"/>
			</svg>
		</div>
		<a href="/website_redesign/content/preface.html">Preface</a>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				1. Overview
			</a>
			<div class="submenu">
				<a href="/website_redesign/content/01_overview/challange.html">1.1 Challenge in Connecting EEG MEG to Neural Circuits </a>
				<a href="/website_redesign/content/01_overview/using_hnn.html">1.2 How HNN solve the Challenge by Bridging Scales</a>
				<a href="/website_redesign/content/01_overview/sample_workflow.html">1.3 Overview of the Simulation Workflow</a>
			</div>
		</div>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				2. Background
			</a>
			<div class="submenu">
				<a href="/website_redesign/content/02_background/biophysical_modeling.html">2.1 Challenge in Connecting EEG MEG to Neural Circuits </a>
				<a href="/website_redesign/content/02_background/signal_origins.html">2.2 The Origins of Source Localize MEG/EEG Primary Currents</a>
				<a href="/website_redesign/content/02_background/glossary.html">2.3 Glossary of Terms</a>
			</div>
		</div>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				3. Assumptions and Validation
			</a>
			<div class="submenu">
				<a href="/website_redesign/content/03_assumptions/template_model.html">3.1 Template Model</a>
				<a href="/website_redesign/content/03_assumptions/cortical_column_structure.html">3.2 Cortical Column Structure</a>
				<a href="/website_redesign/content/03_assumptions/primary_electric_currents.html">3.3 Primary Electrical Currents</a>
				<a href="/website_redesign/content/03_assumptions/neurons_morphology_and_physiology.html">3.4 Neurons: Morphology and Physiology</a>
				<a href="/website_redesign/content/03_assumptions/synaptic_connectivity.html">3.5 Synaptic Connectivity</a>
				<a href="/website_redesign/content/03_assumptions/evoked_and_rhythmic_driving_inputs.html">3.6 Evoked and Rhythmic Driving Inputs</a>
				<a href="/website_redesign/content/03_assumptions/tonic_and_noisy_driving_inputs.html">3.7 Tonic and Noisy Driving Inputs</a>
			</div>
		</div>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				4. Using HNN
			</a>
			<div class="submenu">
				<a href="/website_redesign/content/04_using_hnn/installation.html">4.1 Installation</a>
				<a href="/website_redesign/content/04_using_hnn/network_parameters.html">4.2 Network Parameters</a>
				<a href="/website_redesign/content/04_using_hnn/drive_parameters.html">4.3 Drive Parameters</a>
				<a href="/website_redesign/content/04_using_hnn/loading_data.html">4.4 Loading Data</a>
				<a href="/website_redesign/content/04_using_hnn/running_simulations.html">4.5 Running Simulations</a>
				<a href="/website_redesign/content/04_using_hnn/plotting_firing_patterns.html">4.6 Plotting Firing Patterns</a>
				<a href="/website_redesign/content/04_using_hnn/recording_lfp.html">4.7 Recording and Plotting LFP</a>
				<a href="/website_redesign/content/04_using_hnn/animating_simulations.html">4.8 Animating Simulations</a>
				<a href="/website_redesign/content/04_using_hnn/more_visualizations.html">4.9 Additional Visualizations</a>
				<a href="/website_redesign/content/04_using_hnn/parallelizing.html">4.10 Running Parallel Simulations</a>
				<a href="/website_redesign/content/04_using_hnn/optimization.html">4.11 Optimizing Evoked Responses and Rhythms</a>
				<a href="/website_redesign/content/04_using_hnn/batch_simulation.html">4.12 Running Batch Simulations</a>
			</div>
		</div>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				5. Simulating ERPs
			</a>
			<div class="submenu">
				<a href="/website_redesign/content/05_erps/erps_in_gui.html">2.1 GUI Tutorial of ERP Simulation</a>
				<a href="/website_redesign/content/05_erps/hnn_core.html">2.2 API Tutorial of ERP Simulation</a>
			</div>
		</div>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				6. Simulating Alpha/Beta Rhythms
			</a>
			<div class="submenu">
				<a href="/website_redesign/content/06_alpha_beta/gui.html">6.1 GUI Tutorial of Alpha/Beta Rhythms</a>
				<a href="/website_redesign/content/06_alpha_beta/api.html">6.2 API Tutorial of Alpha/Beta Rhythms</a>
			</div>
		</div>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				7. Simulating Gamma Rhythms
			</a>
			<div class="submenu">
				<a href="/website_redesign/content/07_gamma/gamma_in_gui.html">7.1 GUI Tutorial of Gamma Rhythms</a>
				<a href="/website_redesign/content/07_gamma/gamma_in_api.html">7.2 API Tutorial of Gamma Rhythms</a>
			</div>
		</div>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				8. From Data to Simulation
			</a>
			<div class="submenu">
			</div>
		</div>
		<div class="sidebar-list">
			<a id="sidebar-header" onclick="toggleSubmenu(event)">
		<span class="toggle-icon">+</span>
				9. Feature Demos
			</a>
			<div class="submenu">
				<a href="/website_redesign/content/09_feature_demos/plot_firing_pattern.html">9.1 Plot Firing Pattern</a>
				<a href="/website_redesign/content/09_feature_demos/record_and_plot_extracellular_potentials.html">9.2 Record & Plot Extracellular Potentials</a>
				<a href="/website_redesign/content/09_feature_demos/modifying_local_connectivity.html">9.3 Modifying Local Connectivity</a>
				<a href="/website_redesign/content/09_feature_demos/animating_hnn_simulations.html">9.4 Animating HNN Simulations</a>
				<a href="/website_redesign/content/09_feature_demos/batch_simulation.html">9.5 Batch Simulation</a>
				<a href="/website_redesign/content/09_feature_demos/simulate_beta_modulated_erp.html">9.6 Simulate beta-modulated ERP</a>
				<a href="/website_redesign/content/09_feature_demos/use_mpi_backend_for_parallelization.html">9.7 Use MPI Backend for Parallelization</a>
				<a href="/website_redesign/content/09_feature_demos/optimize_evoked.html">9.8 Optimize simulated evoked response parameters</a>
				<a href="/website_redesign/content/09_feature_demos/optimize_rhythmic.html">9.9 Optimize simulated rhythmic response parameters</a>
			</div>
		</div>
	<div style='height: 30px;'></div>
	</div>

<div id="main">
    <div class="topbar">

        <!-- Topbar menu -->
        <div class="menu-container">
            <div class="menu-icons">
                <button class="openbtn" onclick="toggleNav()">
                    ☰
                </button>
                <a href="" class="home-link">
                    <div class="home-icon-container">
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="24" 
                            height="24"
                            viewBox="0 0 24 24" 
                            class="home-icon">
                            <path
                                d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"
                            />
                        </svg>
                    </div>
                </a>
                <button class="theme-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                        <path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
                    </svg>
                </button>
                <div class="dropdown">
                    <button 
                        id="dropdownButton" 
                        class="dropdown-button">
                            <img
                                src="/website_redesign/content/assets/icons/fontsize.png"
                                alt="fontsize"
                            />
                    </button>
                    <div class="dropdown-content">
                        <button 
                            class="fontsize-btn" 
                            onclick="decreaseFontSize()">
                            <img
                                src="/website_redesign/content/assets/icons/fontminus.png"
                                alt="fontminus"
                            />
                        </button>
                        <button 
                            class="fontsize-btn" 
                            onclick="increaseFontSize()">
                            <img
                                src="/website_redesign/content/assets/icons/fontplus.png"
                                alt="fontplus"
                            />
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Topbar image -->
        <img 
            id="topbar-logo"
            src="https://hnn.brown.edu/wp-content/uploads/hnn-medium.png"
        />

        <!-- Right side of topbar -->
        <div class="socials-container">
            <div class="social-icons">
                <a 
                    href="https://github.com/jonescompneurolab/hnn-core" 
                    target="_blank" 
                    aria-label="GitHub">
                    <img 
                        src="/website_redesign/content/assets/icons/github.png"
                        alt="GitHub">
                </a>
                <a 
                    href="https://bsky.app/profile/hnnsolver.bsky.social" 
                    target="_blank"
                    aria-label="BlueSky">
                    <img 
                        src="/website_redesign/content/assets/icons/bluesky.png"
                        alt="BlueSky">
                </a>
                <a 
                    href="https://www.linkedin.com/company/human-neocortical-neurosolver/" 
                    target="_blank"
                    aria-label="LinkedIn">
                    <img 
                        src="/website_redesign/content/assets/icons/linkedin.png"
                        alt="LinkedIn">
                </a>
            </div>
        </div>
    </div>

    <div id="content-wrapper">
    <div id="content">

<!--
# Title: 6.2 API Tutorial of Alpha/Beta Rhythms
# Updated: 2025-02-04
#
# Contributors:
    # Dylan Daniels
    # Mainak Jas <mmjas@mgh.harvard.edu>
    # Sam Neymotin <samnemo@gmail.com>
    # Blake Caldwell <blake_caldwell@brown.edu>
    # Christopher Bailey <cjb@cfin.au.dk>
-->
<div class='markdown-cell'>    <h1>Welcome to the HNN-Core Alpha and Beta tutorial</h1>
<h2>Getting Started</h2>
<p>This tutorial follows the <a
href="https://jonescompneurolab.github.io/hnn-tutorials/alpha_and_beta/alpha_and_beta">HNN-GUI
tutorial</a> with python commands instead of through a graphical user
interface. We'll begin with some background on the experimental data
used in this tutorial, and then give you a quick introduction to the
HNN-Core API. Finally, we'll show you how to adjust model parameters to
test specific hypotheses using HNN simulations.</p>

</div><div class='markdown-cell'>
    <h2>0. Scientific Background</h2>
<p>In order to understand the workflow and initial parameter sets
provided with this tutorial, we must first briefly describe prior
studies that led to the creation of the data you will aim to simulate.
This tutorial is based on results from Jones et al. 2009 where, using
MEG, we recorded spontaneous (pre-stimulus) alpha (7-14 Hz) and beta
(15-20 Hz) rhythms that arise as part of the mu-complex from the primary
somatosensory cortex (S1) <a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>. (Figure 1. See also[^2], [^3], [^4].)</p>
<h3>Figure 1</h3>
<p><img
src="https://raw.githubusercontent.com/jonescompneurolab/jones-website/master/images/textbook/content/06_alpha_beta/images/image03.png" /></p>
<p><strong>Figure 1 Left</strong>: Spectrogram of spontaneous activity
from current dipole source in SI averaged across 100 trials, from an
example subject, shows nearly continuous prestimulus alpha and beta
oscillations. At time zero, a brief tap was given to the contralateral
finger tip and the spontaneous oscillations briefly desynchronized.</p>
<p><strong>Figure 1 Right</strong>: A closer look at the prestimulus
waveform and spectrogram from spontaneous activity during example signal
trials, shows that the alpha and beta oscillations occur intermittently
and primarily non-overlapping.</p>
<p>Our goal was to use our neocortical model to reproduce features of
the waveform and spectrogram observed on single unaveraged trials
(Figure 2 top panel, right) where the alpha and beta components emerge
briefly and intermittently in time. On any individual trial (i.e., 1
second of spontaneous data), the presence of alpha and beta activity is
not time locked and representative of so-called “induced” activity.
Seemingly continuous bands of activity occur only when averaging the
spectrograms across trials (Figure 2 top panel, left), and this is due
to the fact that the spectrograms values are strictly positive and thealpha and beta events accumulate without cancellation [4].</p>
<h3>Figure 2</h3>
<p><img
src="https://raw.githubusercontent.com/jonescompneurolab/jones-website/master/images/textbook/content/06_alpha_beta/images/old-image29.png" />
<strong>Figure 2</strong>: Key features of the spontaneous non-average
SI alpha/beta complex include, intermittent transient bouts of
alpha/beta activity, a waveform that oscillates around 0nAm, PSD with
peaks in the alpha and beta bands, primarily non-overlapping alpha and
beta events, and a symmetric waveform oscillation. The model was able to
reproduce each of these features.</p>
<p>We found that a sequence of exogenous subthreshold excitatory
synaptic drive could activate the network in a manner that reproduced
important features of the SI rhythms in the model (Figure 2). This drive
consisted of two nearly-synchronous 10 Hz rhythmic drives that contacted
the network through proximal and distal projection pathways (Figure 3).
The drives were simulated as population “bursts” of action potentials
that contacted the network every 100ms with the mean delay between the
proximal and distal burst of 0ms. Specifically, as shown schematically
in Figure 3, the population bursts consisted of 10, 2-spike bursts
Gaussian distributed in time. We presumed that during such spontaneous
activity, these drives may be provided by leminscial and non-lemniscal
thalamic nuclei, which contact proximal and distal pyramidal neurons
respectively, and they are know to burst fire at ~10 Hz frequencies inspontaneous states [^5], [^6].</p>
<h3>Figure 3</h3>
<p><img
src="https://raw.githubusercontent.com/jonescompneurolab/jones-website/master/images/textbook/content/06_alpha_beta/images/image04.png" />
<strong>Figure 3</strong>: Schematic illustration of exogenous 10 Hz
burst drive through proximal and distal projection pathways. “Population
bursts”, consisting of a set number of “burst units” (10, 2-spike bursts
shown) drive post-synaptic conductances in the local network with a set
frequency (100 ms ISI) and mean delay between proximal and distal.</p>
<p>We assumed that the macroscale rhythms generating the observed alpha
and beta activity arose from subthreshold current flow in a large
population of neurons, as opposed to being generated by local spiking
interaction. As such, the effective strengths of the exogenous driving
inputs were tuned so that the cells in the network remained subthreshold
(all other parameters were tuned and fixed base on the morphology,
physiology and connectivity within layered neocortical circuits, see
Jones et al. 2009 [1] for details). The inputs drove subthreshold
currents up and down the pyramidal neurons to reproduce accurate
waveform and spectrogram features (see Figure 3). A scaling factor of
3000 was multiplied by the model waveform to reproduce nAm units
comparable to the recorded data, suggesting on the order 200 x 3000 =
600,000 pyramidal neurons contributed to this signal.</p>
<p>We further found that decreasing the delay between the drives to
~50ms created a pure alpha oscillation, while applying an ~0ms delay
caused beta events to emerge and increased the strength of the distal
drive, creating stronger beta activity (data not shown; see parameter
exploration below). This result led to the novel prediction that brief
beta events emerge from a broad proximal drive disrupted by a
simultaneous strong distal drive that lasted 50ms (i.e., one beta
period). Support for this prediction was found invasively with laminar
recordings in mice and monkeys [3].</p>
<p>In this tutorial, we will explore parameter changes that illustrate
these results. We will walk you step-by-step through simulations with
various combinations of rhythmic proximal and distal drives to describe
how each contributes to the alpha and beta components of the SI
alpha/beta complex rhythm. We will begin by simulating only rhythmic
proximal alpha frequency inputs (Step 1), followed by simulating only
distal alpha frequency inputs (Step 2), followed by various combinations
of proximal and distal drive to generate alpha and beta rhythms. We’ll
show you how HNN can plot waveforms, time-frequency spectrograms, and
power spectral density plots of the simulated data, as well as forimported recorded data.</p>
<h3>References</h3>
<ol type="1">
<li>Jones, S. R. et al. Quantitative analysis and biophysically
realistic neural modeling of the MEG mu rhythm: rhythmogenesis and
modulation of sensory-evoked responses. J. Neurophysiol. 102, 3554–3572
(2009).</li>
</ol>
<ol start="2" type="1">
<li><p>Ziegler, D. A. et al. Transformations in oscillatory activity and
evoked responses in primary somatosensory cortex in middle age: a
combined computational neural modeling and MEG study. Neuroimage 52,
897–912 (2010).</p></li>
<li><p>Sherman, M. A. et al. Neural mechanisms of transient neocortical
beta rhythms: Converging evidence from humans, computational modeling,
monkeys, and mice. Proc. Natl. Acad. Sci. U. S. A. 113, E4885–94
(2016).</p></li>
<li><p>Jones, S. R. When brain rhythms aren’t ‘rhythmic’: implication
for their mechanisms and meaning. Curr. Opin. Neurobiol. 40, 72–80
(2016).</p></li>
<li><p>Jones, E. G. The thalamic matrix and thalamocortical synchrony.
Trends Neurosci. 24, 595–601 (2001).</p></li>
<li><p>Hughes, S. W. &amp; Crunelli, V. Thalamic mechanisms of EEG alpha
rhythms and their pathological implications. Neuroscientist 11, 357–372
(2005).</p></li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Jones, S. R. et al. Quantitative analysis and
biophysically realistic neural modeling of the MEG mu rhythm:
rhythmogenesis and modulation of sensory-evoked responses. J.
Neurophysiol. 102, 3554–3572 (2009).<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</div><div class='markdown-cell'>
    <h2>0. Importing python libraries and loading data</h2>

</div>
<div class='code-cell'>
    <code class='language-python'>
        import numpy as np
import matplotlib.pyplot as plt

import hnn_core
from hnn_core import jones_2009_model, simulate_dipole, MPIBackend, JoblibBackend, read_dipole
from hnn_core.viz import plot_dipole, plot_tfr_morlet, plot_psd
    </code>
</div><div class='markdown-cell'>
    <h2>1. Simulating Rhythmic Proximal Inputs: Alpha Only</h2>
<p>As described in the introduction, low-frequency alpha and beta
rhythms can be simulated by a combination of rhythmic subthreshold
proximal and distal ~10Hz inputs. Here, we begin by describing theimpact of proximal inputs only.</p>
<h3>1.1 Define network and drives</h3>
<p>Let's start with instantiating our network. We will give it the
unique name <code>net_alpha_prox</code> so that we can compare it with
simulation results later on.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        net_alpha_prox = jones_2009_model()
    </code>
</div>
<div class='markdown-cell'>
    <p>TODO AES nanosiemens? or uS? are drives vs real synapses using
different units?</p>
<p>When defining drives, there are several parameters that must be
defined. Here we start with connection weights and delays of our
proximal drive. For the weights, there are AMPA and NMDA receptors on
each cell type (pyramidal and basket cells). To specify the maximum
conductance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>g</mi><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{g}</annotation></semantics></math>
in nanosiemens (nS), we will use a dictionary
<code>weights_ampa_p</code> where the keys specify the cell type. The
delay parameters <code>syn_delays_p</code> control the arrival time of
each spike to the network. In this example, the delay to the layer 2/3
cells is 0.1 ms, with a slightly longer delay to the layer 5 cells of 1
ms.</p>
<p>Note that cells not specified in the dictionary will not recieve
input from the drive.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        weights_ampa_p = {'L2_pyramidal': 5.4e-5, 'L5_pyramidal': 5.4e-5}
syn_delays_p = {'L2_pyramidal': 0.1, 'L5_pyramidal': 1.0}

net_alpha_prox.add_bursty_drive(
    'alpha_prox', tstart=50.0, tstart_std=0.0, burst_rate=10, burst_std=20, numspikes=2,
    spike_isi=10, n_drive_cells=10, location='proximal',
    weights_ampa=weights_ampa_p, synaptic_delays=syn_delays_p, event_seed=14)
    </code>
</div>
<div class='markdown-cell'>
    <p>The rhythmic proximal inputs defined above drive excitatory synapses
in the neocortical network in a proximal projection pattern, as shown
below AES in Figure 4. For further details on the connectivity structure
of the network, see the (AES TODO link) Under the Hoodsection of the HNN
website. Rhythmic proximal input occurs through stochastic, presynaptic
bursts of action potentials from a population of bursting cells (set
with <code>n_drive_cells</code>; see Figure 3) onto postsynaptic neurons
of the modelled network. Stochasticity is introduced in two places: the
spike train start time for each bursting cell is sampled from a normal
distribution with mean start time mean (ms) <code>tstart</code> and
standard deviation (ms) <code>tstart_std</code> and the inter-burst
intervals for each bursting cell are sampled from a normal distribution
of mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">F</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">y</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{1}{\mathrm{Burst Frequency}}</annotation></semantics></math>
(with "Burst Frequency" corresponding to <code>burst_rate</code>, e.g.,
a 100 ms inter-burst interval corresponds to a “Burst frequency” of 10
Hz) and standard deviation <code>burst_std</code> (see Figure 3). Also
note that the number of spikes per burst unit is set with
<code>num_spikes</code>, an inter-spike interval by
<code>spike_isi</code>, and the final stop time for the entire
population of rhythmic proximal inputs is set with <code>tstop</code>
(here the parameter is not included which produces repeating burststhroughout the simulation).</p>
<h3>Figure 4</h3>
<p><img
src="https://raw.githubusercontent.com/jonescompneurolab/jones-website/master/images/textbook/content/06_alpha_beta/images/prox-drive.png" /></p>

</div>
<div class='markdown-cell'>
    <p>We can check that the drives have been added by looking at</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        net_alpha_prox.external_drives
    </code>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        {&#x27;alpha_prox&#x27;: &lt;External drive &#x27;alpha_prox&#x27;
 drive class: bursty
 target location: proximal
 target cell types: {&#x27;L2_pyramidal&#x27;, &#x27;L5_pyramidal&#x27;}
 number of drive cells: 10
 cell-specific: False
 dynamic parameters:
     tstart: 50.0
     tstart_std: 0.0
     tstop: None
     burst_rate: 10
     burst_std: 20
     numspikes: 2
     spike_isi: 10&gt;}
    </div>
</div><div class='markdown-cell'>
    <h3>1.2 Run the simulation and visualize net current dipole</h3>
<p>Now, we simulate the dipole with just one trial for now. Note that we
have set <code>tstop</code> to 710 ms giving us a sufficiently long
simulation to visualize oscillatory activity.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        dpl_alpha_prox = simulate_dipole(net_alpha_prox, tstop=710.0, n_trials=1)
    </code>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        Joblib will run 1 trial(s) in parallel by distributing trials over 1 jobs.
Loading custom mechanism files from /opt/homebrew/Caskroom/miniconda/base/envs/py311/lib/python3.11/site-packages/hnn_core/mod/arm64/.libs/libnrnmech.so
Building the NEURON model
[Done]
Trial 1: 0.03 ms...
Trial 1: 10.0 ms...
Trial 1: 20.0 ms...
Trial 1: 30.0 ms...
Trial 1: 40.0 ms...
Trial 1: 50.0 ms...
Trial 1: 60.0 ms...
Trial 1: 70.0 ms...
Trial 1: 80.0 ms...
Trial 1: 90.0 ms...
Trial 1: 100.0 ms...
Trial 1: 110.0 ms...
Trial 1: 120.0 ms...
Trial 1: 130.0 ms...
Trial 1: 140.0 ms...
Trial 1: 150.0 ms...
Trial 1: 160.0 ms...
Trial 1: 170.0 ms...
Trial 1: 180.0 ms...
Trial 1: 190.0 ms...
Trial 1: 200.0 ms...
Trial 1: 210.0 ms...
Trial 1: 220.0 ms...
Trial 1: 230.0 ms...
Trial 1: 240.0 ms...
Trial 1: 250.0 ms...
Trial 1: 260.0 ms...
Trial 1: 270.0 ms...
Trial 1: 280.0 ms...
Trial 1: 290.0 ms...
Trial 1: 300.0 ms...
Trial 1: 310.0 ms...
Trial 1: 320.0 ms...
Trial 1: 330.0 ms...
Trial 1: 340.0 ms...
Trial 1: 350.0 ms...
Trial 1: 360.0 ms...
Trial 1: 370.0 ms...
Trial 1: 380.0 ms...
Trial 1: 390.0 ms...
Trial 1: 400.0 ms...
Trial 1: 410.0 ms...
Trial 1: 420.0 ms...
Trial 1: 430.0 ms...
Trial 1: 440.0 ms...
Trial 1: 450.0 ms...
Trial 1: 460.0 ms...
Trial 1: 470.0 ms...
Trial 1: 480.0 ms...
Trial 1: 490.0 ms...
Trial 1: 500.0 ms...
Trial 1: 510.0 ms...
Trial 1: 520.0 ms...
Trial 1: 530.0 ms...
Trial 1: 540.0 ms...
Trial 1: 550.0 ms...
Trial 1: 560.0 ms...
Trial 1: 570.0 ms...
Trial 1: 580.0 ms...
Trial 1: 590.0 ms...
Trial 1: 600.0 ms...
Trial 1: 610.0 ms...
Trial 1: 620.0 ms...
Trial 1: 630.0 ms...
Trial 1: 640.0 ms...
Trial 1: 650.0 ms...
Trial 1: 660.0 ms...
Trial 1: 670.0 ms...
Trial 1: 680.0 ms...
Trial 1: 690.0 ms...
Trial 1: 700.0 ms...

    </div>
</div>
<div class='markdown-cell'>
    <p>The simulation is a bit slow. If we want to speed it up, we can use
MPI. It's a protocol that splits the simulation across neurons. You
might need to follow a few extra installation steps to install MPI
dependencies if you wish to run <code>MPIBackend</code> on your machine
(see <a
href="https://jonescompneurolab.github.io/hnn-core/stable/parallel.html">here</a>).</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # simulate dipole with a specific parallel backend (1 trial)
# we'll use MPIBackend for the remainder of this tutorial as it is the fastest

n_procs = 8

with MPIBackend(n_procs=n_procs):
    dpl_alpha_prox = simulate_dipole(net_alpha_prox, tstop=710.0, n_trials=1)
    
# If you don't have the OpenMPI and mpi4py installed on you machine,
# you can alternatively use JoblibBackend (uncomment lines below) to 

# with JoblibBackend(n_jobs=n_procs):
#    dpls = simulate_dipole(net_alpha_prox, tstop=710.0, n_trials=1)

    </code>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        MPIBackend is set to use 1 core: tranferring the simulation to JoblibBackend....
Joblib will run 1 trial(s) in parallel by distributing trials over 1 jobs.
Building the NEURON model

        [Done]
Trial 1: 0.03 ms...
Trial 1: 10.0 ms...
Trial 1: 20.0 ms...
Trial 1: 30.0 ms...
Trial 1: 40.0 ms...
Trial 1: 50.0 ms...
Trial 1: 60.0 ms...
Trial 1: 70.0 ms...
Trial 1: 80.0 ms...
Trial 1: 90.0 ms...
Trial 1: 100.0 ms...
Trial 1: 110.0 ms...
Trial 1: 120.0 ms...
Trial 1: 130.0 ms...
Trial 1: 140.0 ms...
Trial 1: 150.0 ms...
Trial 1: 160.0 ms...
Trial 1: 170.0 ms...
Trial 1: 180.0 ms...
Trial 1: 190.0 ms...
Trial 1: 200.0 ms...
Trial 1: 210.0 ms...
Trial 1: 220.0 ms...
Trial 1: 230.0 ms...
Trial 1: 240.0 ms...
Trial 1: 250.0 ms...
Trial 1: 260.0 ms...
Trial 1: 270.0 ms...
Trial 1: 280.0 ms...
Trial 1: 290.0 ms...
Trial 1: 300.0 ms...
Trial 1: 310.0 ms...
Trial 1: 320.0 ms...
Trial 1: 330.0 ms...
Trial 1: 340.0 ms...
Trial 1: 350.0 ms...
Trial 1: 360.0 ms...
Trial 1: 370.0 ms...
Trial 1: 380.0 ms...
Trial 1: 390.0 ms...
Trial 1: 400.0 ms...
Trial 1: 410.0 ms...
Trial 1: 420.0 ms...
Trial 1: 430.0 ms...
Trial 1: 440.0 ms...
Trial 1: 450.0 ms...
Trial 1: 460.0 ms...
Trial 1: 470.0 ms...
Trial 1: 480.0 ms...
Trial 1: 490.0 ms...
Trial 1: 500.0 ms...
Trial 1: 510.0 ms...
Trial 1: 520.0 ms...
Trial 1: 530.0 ms...
Trial 1: 540.0 ms...
Trial 1: 550.0 ms...
Trial 1: 560.0 ms...
Trial 1: 570.0 ms...
Trial 1: 580.0 ms...
Trial 1: 590.0 ms...
Trial 1: 600.0 ms...
Trial 1: 610.0 ms...
Trial 1: 620.0 ms...
Trial 1: 630.0 ms...
Trial 1: 640.0 ms...
Trial 1: 650.0 ms...
Trial 1: 660.0 ms...
Trial 1: 670.0 ms...
Trial 1: 680.0 ms...
Trial 1: 690.0 ms...
Trial 1: 700.0 ms...

    </div>
</div>
<div class='markdown-cell'>
    <p>To help visualize simulation results, HNN-Core comes equipped with
several visualization functions. You can learn more about the in built
plotting functions by browsing some of the examples <a
href="https://jonescompneurolab.github.io/hnn-core/stable/auto_examples/index.html">here</a>.
For now, we are going to utilize the <code>plot_spike_hist()</code>,
<code>plot_dipole()</code>, and <code>plot_tfr_morlet()</code>
functions. Let's package these into a function so that we can reuse to
visualize simulation results later on.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        def simulation_plots(net, dpl, xlim=[0, 710]):
    # Set up 3 panel figure
    fig, axes = plt.subplots(3, 1, sharex=True, figsize=(7, 7), constrained_layout=True)

    # Plot histogram of proximal and distal drive spike times
    net.cell_response.plot_spikes_hist(ax=axes[0], show=False)
    axes[0].set_title('Input Histogram')

    # Plot aggregate current dipole
    plot_dipole(dpl, ax=axes[1], layer='agg', show=False, tmin=xlim[0], tmax=xlim[1])
    
    # Plot spectrogram with frequencies from 6 to 60 Hz in steps of 1 Hz
    freqs = np.arange(6.0, 30.0, 1.0)
    plot_tfr_morlet(dpl, freqs, n_cycles=7, ax=axes[2], tmin=xlim[0], tmax=xlim[1])
    axes[2].set_title('Spectrogram')

    return fig
    </code>
</div>
<div class='markdown-cell'>
    <p>From now on all we have to do is call the function
<code>simulate_plots()</code> with the <code>Network</code> and
<code>Dipole</code> objects to make our plots.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # AES TODO why does it show twice? maybe the dpl is a list?
simulation_plots(net_alpha_prox, dpl_alpha_prox)
    </code>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        &lt;Figure size 700x700 with 4 Axes&gt;
    </div>
</div>
<div class='output-cell'>
    <img src='output_nb_api_alpha_beta/fig_01.png'/>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        &lt;Figure size 700x700 with 4 Axes&gt;
    </div>
</div>
<div class='output-cell'>
    <img src='output_nb_api_alpha_beta/fig_02.png'/>
</div>
<div class='markdown-cell'>
    <p>In this parameter set, a burst of proximal input spikes is provided
to the network ~10 Hz (i.e., every 100 ms). Due to the stochastic nature
of the inputs (controlled by the <code>tstart</code>,
<code>tstart_std</code>, <code>burst_std</code> parameters), there is
some variability in the histogram of proximal input times. Note that a
decrease in the <code>burst_std</code> would create shorter duration
bursts (i.e., more synchronous bursts); this will be explored further in
step 6.1 below.</p>
<p>The ~10 Hz bursts of proximal drive induces current flow up the
pyramidal neuron dendrites increasing the signal above the 0 nAm
baseline, which then relaxes back to zero, approximately every 100 ms.
This is observed in the black current dipole waveform in the figure. The
bottom panel shows the corresponding time-frequency spectrogram for this
waveform that exhibits a high-power continuous 10 Hz signal.
Importantly, in this example the strength of the proximal input was
titrated to be subthreshold (i.e., cells do not spike) under the
assumption that macroscale oscillations are generated primarily by
subthreshold current flow across large populations of synchronous
pyramidal neurons. In step 6.2 below, we explore differences in the
signal when the cells are driven to spike (see also TODO AES link
'erp_tutorial_hnn_core.ipynb').</p>
<p>While this exploration with proximal drive is only useful in
understanding how subthreshold rhythmic inputs impact the current dipole
produced by the circuit, several features of the waveform and
spectrogram of the signal do not match the recorded data shown in
Figures 1and 2. Next, we explore the impact of rhythmic distal inputs
only (step 2), and then a combination of the two (step 3).</p>

</div><div class='markdown-cell'>
    <h2>2. Simulating Rhythmic Distal Inputs: Alpha Only</h2>
<p>Having seen that proximal inputs alone push the current flow only in
a single direction (positive), we can confirm that the same occurs if we
provide only rhythmic distal inputs, which drive current flow in the
pyramidal neuron dendrites, and hence current dipole signal, in theopposite direction (negative).</p>
<h3>2.1 Define network and drives</h3>
<p>We begin again by instantiating the network.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        net_alpha_dist = jones_2009_model()
    </code>
</div>
<div class='code-cell'>
    <code class='language-python'>
        weights_ampa_d = {'L2_pyramidal': 5.4e-5, 'L5_pyramidal': 5.4e-5}
syn_delays_d = {'L2_pyramidal': 5.0, 'L5_pyramidal': 5.0}

net_alpha_dist.add_bursty_drive(
    'alpha_dist', tstart=50.0, tstart_std=0.0, burst_rate=10, burst_std=20, numspikes=2,
    spike_isi=10, n_drive_cells=10, location='distal',
    weights_ampa=weights_ampa_d, synaptic_delays=syn_delays_d, event_seed=14) # Need different seed?
    </code>
</div><div class='markdown-cell'>
    <h3>2.2 Run the simulation and visualize net current dipole</h3>
<p>Now we simulate the dipole.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        with MPIBackend(n_procs=n_procs):
    dpl_alpha_dist = simulate_dipole(net_alpha_dist, tstop=710.0, n_trials=1)

# dpl_alpha_dist = simulate_dipole(net_alpha_dist, tstop=710.0, n_trials=1)
    </code>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        MPIBackend is set to use 1 core: tranferring the simulation to JoblibBackend....
Joblib will run 1 trial(s) in parallel by distributing trials over 1 jobs.
Building the NEURON model
[Done]
Trial 1: 0.03 ms...
Trial 1: 10.0 ms...
Trial 1: 20.0 ms...
Trial 1: 30.0 ms...
Trial 1: 40.0 ms...
Trial 1: 50.0 ms...
Trial 1: 60.0 ms...
Trial 1: 70.0 ms...
Trial 1: 80.0 ms...
Trial 1: 90.0 ms...
Trial 1: 100.0 ms...
Trial 1: 110.0 ms...
Trial 1: 120.0 ms...
Trial 1: 130.0 ms...
Trial 1: 140.0 ms...
Trial 1: 150.0 ms...
Trial 1: 160.0 ms...
Trial 1: 170.0 ms...
Trial 1: 180.0 ms...
Trial 1: 190.0 ms...
Trial 1: 200.0 ms...
Trial 1: 210.0 ms...
Trial 1: 220.0 ms...
Trial 1: 230.0 ms...
Trial 1: 240.0 ms...
Trial 1: 250.0 ms...
Trial 1: 260.0 ms...
Trial 1: 270.0 ms...
Trial 1: 280.0 ms...
Trial 1: 290.0 ms...
Trial 1: 300.0 ms...
Trial 1: 310.0 ms...
Trial 1: 320.0 ms...
Trial 1: 330.0 ms...
Trial 1: 340.0 ms...
Trial 1: 350.0 ms...
Trial 1: 360.0 ms...
Trial 1: 370.0 ms...
Trial 1: 380.0 ms...
Trial 1: 390.0 ms...
Trial 1: 400.0 ms...
Trial 1: 410.0 ms...
Trial 1: 420.0 ms...
Trial 1: 430.0 ms...
Trial 1: 440.0 ms...
Trial 1: 450.0 ms...
Trial 1: 460.0 ms...
Trial 1: 470.0 ms...
Trial 1: 480.0 ms...
Trial 1: 490.0 ms...
Trial 1: 500.0 ms...
Trial 1: 510.0 ms...
Trial 1: 520.0 ms...
Trial 1: 530.0 ms...
Trial 1: 540.0 ms...
Trial 1: 550.0 ms...
Trial 1: 560.0 ms...
Trial 1: 570.0 ms...
Trial 1: 580.0 ms...
Trial 1: 590.0 ms...
Trial 1: 600.0 ms...
Trial 1: 610.0 ms...
Trial 1: 620.0 ms...
Trial 1: 630.0 ms...
Trial 1: 640.0 ms...
Trial 1: 650.0 ms...
Trial 1: 660.0 ms...
Trial 1: 670.0 ms...
Trial 1: 680.0 ms...
Trial 1: 690.0 ms...
Trial 1: 700.0 ms...

    </div>
</div>
<div class='markdown-cell'>
    <p>We can use the in built plotting functions of hnn-core to visualize
the simulated dipole.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        simulation_plots(net_alpha_dist, dpl_alpha_dist)
    </code>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        &lt;Figure size 700x700 with 4 Axes&gt;
    </div>
</div>
<div class='output-cell'>
    <img src='output_nb_api_alpha_beta/fig_03.png'/>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        &lt;Figure size 700x700 with 4 Axes&gt;
    </div>
</div>
<div class='output-cell'>
    <img src='output_nb_api_alpha_beta/fig_04.png'/>
</div>
<div class='markdown-cell'>
    <p>As shown in the histogram in the top panel of figure above, with this
parameter set, a burst of distal input spikes is provided to the network
~10 Hz (i.e., every 100 ms). Due to the stochastic nature of the inputs
(controlled by the start time stdev, and Burst stdev parameters), there
is some variability in the histogram of proximal input times. The ~10 Hz
bursts of distal input induces current flow down the pyramidal neuron
dendrites decreasing the signal below the 0 nAm baseline, which then
relaxes back to zero, approximately every 100 ms. This is observed in
the black current dipole waveform in the figure. The bottom panel shows
the corresponding time-frequency spectrogram for this waveform that
exhibits a high power continuous 10 Hz signal. Importantly, in this
example the strength of the distal input was also titrated to be
subthreshold (i.e., cells do not spike) under the assumption that
macroscale oscillations are generated primarily by subthreshold current
flow across large populations of synchronous pyramidal neurons.</p>
<p>While instructional, this simulation also does not produce waveform
and spectral features that match the experimental data in Figures 1 and
2. In the next step (step 3), we describe how combining both the 10 Hz
proximal and distal drives can produce an oscillation with many
characteristic features of the spontaneous SI signal (Jones et al
2009).</p>

</div>
<div class='markdown-cell'>
    <h2>3. Simulating Combined Rhythmic Proximal and Distal Inputs:
Alpha/Beta Complex</h2>
<p>In this simulation, the Start time mean (ms) values
<code>tstart</code> for both proximal and distal inputs are set to 50.0
ms, and all other parameters are the same. Note that the synaptic
weights are the same as used in the previous two simulations. The equal
start time implies that the proximal and distal input bursts will arrive
nearly synchronously to the network on each cycle of the 10 Hz input.
Due to the stochasticity in the parameters (start time stdev, and Burst
stdev) sometimes the bursts will arrive together and sometimes there
will be a slight delay. As will be described further below, thisstochasticity creates intermittent alpha and beta events.</p>
<h3>3.1 Define network and drives</h3>
<p>We begin by instantiating the network, and adding drives with the
same functions as above. Note that the <code>event_seed</code> parameter
must be changed, otherwise the spike times of the proximal and distal
drive would be identical.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        net_alpha_sync = jones_2009_model()

net_alpha_sync.add_bursty_drive(
    'alpha_prox', tstart=50.0, tstart_std=0.0, burst_rate=10, burst_std=20, numspikes=2,
    spike_isi=10, n_drive_cells=10, location='proximal',
    weights_ampa=weights_ampa_p, synaptic_delays=syn_delays_p, event_seed=10)

net_alpha_sync.add_bursty_drive(
    'alpha_dist', tstart=50.0, burst_rate=10, burst_std=20, numspikes=2,
    spike_isi=10, n_drive_cells=10, location='distal',
    weights_ampa=weights_ampa_d, synaptic_delays=syn_delays_d, event_seed=14)
    </code>
</div><div class='markdown-cell'>
    <h3>3.2 Run the simulation and visualize net current dipole</h3>

</div>
<div class='code-cell'>
    <code class='language-python'>
        with MPIBackend(n_procs=n_procs):
    dpl_alpha_sync = simulate_dipole(net_alpha_sync, tstop=710.0, n_trials=1)

# dpl_alpha_sync = simulate_dipole(net_alpha_sync, tstop=710.0, n_trials=1)
    </code>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        MPIBackend is set to use 1 core: tranferring the simulation to JoblibBackend....
Joblib will run 1 trial(s) in parallel by distributing trials over 1 jobs.
Building the NEURON model
[Done]
Trial 1: 0.03 ms...
Trial 1: 10.0 ms...
Trial 1: 20.0 ms...
Trial 1: 30.0 ms...
Trial 1: 40.0 ms...
Trial 1: 50.0 ms...
Trial 1: 60.0 ms...
Trial 1: 70.0 ms...
Trial 1: 80.0 ms...
Trial 1: 90.0 ms...
Trial 1: 100.0 ms...
Trial 1: 110.0 ms...
Trial 1: 120.0 ms...
Trial 1: 130.0 ms...
Trial 1: 140.0 ms...
Trial 1: 150.0 ms...
Trial 1: 160.0 ms...
Trial 1: 170.0 ms...
Trial 1: 180.0 ms...
Trial 1: 190.0 ms...
Trial 1: 200.0 ms...
Trial 1: 210.0 ms...
Trial 1: 220.0 ms...
Trial 1: 230.0 ms...
Trial 1: 240.0 ms...
Trial 1: 250.0 ms...
Trial 1: 260.0 ms...
Trial 1: 270.0 ms...
Trial 1: 280.0 ms...
Trial 1: 290.0 ms...
Trial 1: 300.0 ms...
Trial 1: 310.0 ms...
Trial 1: 320.0 ms...
Trial 1: 330.0 ms...
Trial 1: 340.0 ms...
Trial 1: 350.0 ms...
Trial 1: 360.0 ms...
Trial 1: 370.0 ms...
Trial 1: 380.0 ms...
Trial 1: 390.0 ms...
Trial 1: 400.0 ms...
Trial 1: 410.0 ms...
Trial 1: 420.0 ms...
Trial 1: 430.0 ms...
Trial 1: 440.0 ms...
Trial 1: 450.0 ms...
Trial 1: 460.0 ms...
Trial 1: 470.0 ms...
Trial 1: 480.0 ms...
Trial 1: 490.0 ms...
Trial 1: 500.0 ms...
Trial 1: 510.0 ms...
Trial 1: 520.0 ms...
Trial 1: 530.0 ms...
Trial 1: 540.0 ms...
Trial 1: 550.0 ms...
Trial 1: 560.0 ms...
Trial 1: 570.0 ms...
Trial 1: 580.0 ms...
Trial 1: 590.0 ms...
Trial 1: 600.0 ms...
Trial 1: 610.0 ms...
Trial 1: 620.0 ms...
Trial 1: 630.0 ms...
Trial 1: 640.0 ms...
Trial 1: 650.0 ms...
Trial 1: 660.0 ms...
Trial 1: 670.0 ms...
Trial 1: 680.0 ms...
Trial 1: 690.0 ms...
Trial 1: 700.0 ms...

    </div>
</div>
<div class='code-cell'>
    <code class='language-python'>
        simulation_plots(net_alpha_sync, dpl_alpha_sync)
    </code>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        &lt;Figure size 700x700 with 4 Axes&gt;
    </div>
</div>
<div class='output-cell'>
    <img src='output_nb_api_alpha_beta/fig_05.png'/>
</div>
<div class='output-cell'><div class='output-label'>
    Out:
</div>
    <div class='output-code'>
        &lt;Figure size 700x700 with 4 Axes&gt;
    </div>
</div>
<div class='output-cell'>
    <img src='output_nb_api_alpha_beta/fig_06.png'/>
</div>
<div class='markdown-cell'>
    <p>As shown in the green and red histogram in the top panel of the
figure above, with this parameter set, bursts of both proximal and
distal input spikes are provided to the network ~10 Hz (i.e., every 100
ms). Due to the stochastic nature of the inputs, there is some
variability in the timing and duration of the input bursts such that
sometimes they arrive at the same time and sometimes there is a slight
offset between them. As a result, intermittent transient alpha and beta
events emerge in the time-frequency spectrogram. Alpha events are
produced when the inputs occur slightly out of phase and current flow is
pushed alternately up and down the dendrites for ~50 ms duration each
(set by the length of the bursts inputs). Beta events occur when the
burst inputs arrive more synchronously and the upward current flow is
disrupted by downward current flow for ~50 ms to effectively cut the
oscillation period in half. As such, the relative alpha to beta
expression can be controlled by the delay between the inputs and their
relative burst strengths. We will detail this further below (see step 6
below).</p>
<p>In contrast to the results from only proximal or distal input, since
the current in the pyramidal neurons is pushed both upward and downward
in this simulation, the current dipole signal oscillates above and below
0 nAm, which qualitatively matches the experimental data (see Figures 1
and 2 in “Getting Started”). Additionally, this simulation reproduces
the transient nature of the alpha and beta activity and several other
features of the waveform and spectrogram can be quantified to show close
agreement between model and experimental results (see Figure 2 above,
and Jones et al. 2009[1], for further details).</p>
<p>We note that here we do not directly compare the spontaneous current
dipole waveform to recorded data, as was done in the ERP tutorial with a
root mean squared error. This is due to the fact that the spontaneous SI
signal we are simulating is not time locked to alpha or beta events on
any given trial, and the stochastic nature of the driving inputs causes
variability in the timing of the alpha or beta activity, making it
difficult to align recorded data and simulated results. However, a
direct comparison can be made between time averaged recorded and
simulated signals by comparing power spectral density waveforms. An
example of comparison is shown in step 5 below.</p>

</div>
<div class='markdown-cell'>
    <h3>3.3 Simulating and averaging multiple trials with jittered start
times creates the impression of continuous oscillations</h3>
<p>As described in the “Getting Started” section above, our simulation
goal was to study the mechanisms that reproduce features of spontaneous
alpha and beta rhythms observed in un-averaged data, where the alpha and
beta components are transient and intermittent (Figure 1, right panel).
Each tutorial step up to this point was based on simulating un-averaged
data. Here, we describe how to run and average multiple “trials” (700 ms
epochs of spontaneous activity). We show that, due to the stochastic
nature of the proximal and distal rhythmic input, controlled by the
standard deviation of the start times <code>tstart_std</code>, and the
stdev of the input bursts <code>burst_std</code>, when running multiple
trials, the precise timing of the input bursts on each trial is
jittered, and hence the alpha and beta activity in the spectrograms on
each trial is jittered. This is akin to simulating induced rhythms
rather than time-locked evoked rhythms. In the averaged spectrogram
across trials, the alpha and beta events accumulate without cancellation
(due to the fact that spectrogram value are purely positive) creating
the impression of a continuous oscillation (Figure 1, left panel).</p>
<p>Below we illustrate the effects of “jitter” in the proximal and
distal rhythmic inputs across trials in two ways. First, we examine the
effects of “jitter” due to the <code>burst_std</code>, and second due to
the <code>tstart_std</code>.</p>
<p>To first test the effects of jittering due to <code>burst_std</code>
and averaging across trials, we will use a drive configuration with
rhythmic proximal and distal inputs provided at 10 Hz, with proximal and
distal inputs in phase. These are the same parameters as Step 3.2 above,
but now with 5 trials instead of 1.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        net_alpha_trials = jones_2009_model()

net_alpha_trials.add_bursty_drive(
    'alpha_prox', tstart=50.0, tstart_std=0.0, burst_rate=10, burst_std=20, numspikes=2,
    spike_isi=10, n_drive_cells=10, location='proximal',
    weights_ampa=weights_ampa_p, synaptic_delays=syn_delays_p, event_seed=10)

net_alpha_trials.add_bursty_drive(
    'alpha_dist', tstart=50.0, tstart_std=0.0, burst_rate=10, burst_std=20, numspikes=2,
    spike_isi=10, n_drive_cells=10, location='distal',
    weights_ampa=weights_ampa_d, synaptic_delays=syn_delays_d, event_seed=15)
    
with MPIBackend(n_procs=n_procs):
    dpl_alpha_trials = simulate_dipole(net_alpha_trials, tstop=710.0, n_trials=5)

# dpl_alpha_trials = simulate_dipole(net_alpha_trials, tstop=710.0, n_trials=5)
    </code>
</div>
<div class='output-cell error'>
    <pre>
        [0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
Cell [0;32mIn[1], line 1[0m
[0;32m----> 1[0m net_alpha_trials [38;5;241m=[39m [43mjones_2009_model[49m()
[1;32m      3[0m net_alpha_trials[38;5;241m.[39madd_bursty_drive(
[1;32m      4[0m     [38;5;124m'[39m[38;5;124malpha_prox[39m[38;5;124m'[39m, tstart[38;5;241m=[39m[38;5;241m50.0[39m, tstart_std[38;5;241m=[39m[38;5;241m0.0[39m, burst_rate[38;5;241m=[39m[38;5;241m10[39m, burst_std[38;5;241m=[39m[38;5;241m20[39m, numspikes[38;5;241m=[39m[38;5;241m2[39m,
[1;32m      5[0m     spike_isi[38;5;241m=[39m[38;5;241m10[39m, n_drive_cells[38;5;241m=[39m[38;5;241m10[39m, location[38;5;241m=[39m[38;5;124m'[39m[38;5;124mproximal[39m[38;5;124m'[39m,
[1;32m      6[0m     weights_ampa[38;5;241m=[39mweights_ampa_p, synaptic_delays[38;5;241m=[39msyn_delays_p, event_seed[38;5;241m=[39m[38;5;241m10[39m)
[1;32m      8[0m net_alpha_trials[38;5;241m.[39madd_bursty_drive(
[1;32m      9[0m     [38;5;124m'[39m[38;5;124malpha_dist[39m[38;5;124m'[39m, tstart[38;5;241m=[39m[38;5;241m50.0[39m, tstart_std[38;5;241m=[39m[38;5;241m0.0[39m, burst_rate[38;5;241m=[39m[38;5;241m10[39m, burst_std[38;5;241m=[39m[38;5;241m20[39m, numspikes[38;5;241m=[39m[38;5;241m2[39m,
[1;32m     10[0m     spike_isi[38;5;241m=[39m[38;5;241m10[39m, n_drive_cells[38;5;241m=[39m[38;5;241m10[39m, location[38;5;241m=[39m[38;5;124m'[39m[38;5;124mdistal[39m[38;5;124m'[39m,
[1;32m     11[0m     weights_ampa[38;5;241m=[39mweights_ampa_d, synaptic_delays[38;5;241m=[39msyn_delays_d, event_seed[38;5;241m=[39m[38;5;241m15[39m)

[0;31mNameError[0m: name 'jones_2009_model' is not defined
    </pre>
</div>
<div class='code-cell'>
    <code class='language-python'>
        # Note that a spike is induced on certain trials
# We have excluded trials with spikes since the high-amplitude dipole dominates the average spectrogram
nospike_trials = [0,1,2,3]
dpl_alpha_nospike = [dpl_alpha_trials[idx] for idx in nospike_trials]
simulation_plots(net_alpha_trials, dpl_alpha_nospike)
    </code>
</div>
<div class='markdown-cell'>
    <p>Notice that the input histograms for distal (green) and proximal
(red) input accumulated across the 5 trials, now have higher values than
before (up to ~20 compared to 5 in Step 3.2) and the burst inputs are
slightly broader on each cycle, since these histograms represent the
accumulated activity from 10 simulations, where the standard deviation
in the Burst duration across trials is 20 ms. Approximately 10 Hz
rhythmicity in the timing of the distal and proximal inputs can be
clearly visualized (note also the symmetric profile of the histograms).
However, on any individual trial, the coincidence of inputs leading to
alpha or beta events displays some variability due to the stochastic
parameter value (Burst stdev=20 ms). This is observed in the dipole
waveforms shown for each trial (example shown below). The spectrogram
shown is now created by calculating the spectrogram from each of the 5
trials separately, then averaging the 5 spectrograms. Importantly, this
is not the spectrogram of the average of the dipole waveforms. The
averaged spectrogram above shows more continuous bands of alpha and beta
activity than for a single trial (compare to spectrogram in Step 3).
Running more trials will increase the appearance of continuous
rhythms.</p>
<p>In the next simulation, we will jitter the start times of rhythmic
inputs across trials with the <code>tstartd_std</code>, in addition to a
non-zero <code>burst_std</code>. This will add additional variability to
the timing of the transient alpha and beta events on each trial, and
hence produce even more continuous bands of activity in the averaged
spectrogram.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        net_alpha_jitter = jones_2009_model()

net_alpha_jitter.add_bursty_drive(
    'alpha_prox', tstart=50.0, tstart_std=50.0, burst_rate=10, burst_std=20, numspikes=2,
    spike_isi=10, n_drive_cells=10, location='proximal',
    weights_ampa=weights_ampa_p, synaptic_delays=syn_delays_p, event_seed=10)

net_alpha_jitter.add_bursty_drive(
    'alpha_dist', tstart=50.0, tstart_std=50.0, burst_rate=10, burst_std=20, numspikes=2,
    spike_isi=10, n_drive_cells=10, location='distal',
    weights_ampa=weights_ampa_d, synaptic_delays=syn_delays_d, event_seed=14)

with MPIBackend(n_procs=n_procs):
    dpl_alpha_jitter = simulate_dipole(net_alpha_jitter, tstop=710.0, n_trials=5)

# dpl_alpha_jitter = simulate_dipole(net_alpha_jitter, tstop=710.0, n_trials=5)
    </code>
</div>
<div class='code-cell'>
    <code class='language-python'>
        simulation_plots(net_alpha_jitter, dpl_alpha_jitter)
    </code>
</div>
<div class='markdown-cell'>
    <p>Notice that the input histograms for distal (green) and proximal
(red) input accumulated across the 5 trials now show little rhythmicity
due to the jitter in the rhythmic input start times across trials (Start
time stdv (ms) = 50), in addition to jitter due to the Burst stdev (ms)
= 20. However, if we were to visualize histograms on each individual
trial (using the View spectrograms tab), they would show the ~10 Hz and
20 Hz (alpha and beta) rhythmicity. It is also difficult to visualize
rhythmicity in any of the overlaid dipole waveforms. However, on each
trial, alpha and beta rhythmicity is present, and even more continuous
bands of alpha and beta activity are observed (compare to averaged data
in Figure 1 left panel; n=100 trials) when the spectrograms from
individual trials are averaged. Running more trials will further
increase the continuous nature of alpha and beta activity across
time.</p>

</div><div class='markdown-cell'>
    <h3>3.4 Viewing network spiking activity</h3>
<p>AES TODO</p>

</div><div class='markdown-cell'>
    <h2>4. Calculating and Viewing Power Spectral Density (PSD)</h2>

</div>
<div class='markdown-cell'>
    <p>HNN provides a feature to calculate and view the power spectral
density (PSD) of the simulated signal and imported data (Note: the PSD
is calculated as the time average of the spectrogram, in the simulation
examples).</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        plot_psd(dpl_alpha_jitter, fmin=1.0, fmax=1e3, show=False)
plt.xscale('log')
    </code>
</div>
<div class='markdown-cell'>
    <h2>5. (AES TODO re-introduce) Comparing model output and recorded
data</h2>
<p>We can also use HNN to compare model-generated to empirical PSD,
which represents the averaged activity across time. As discussed above,
HNN does not provide means to directly compare spontaneous time domain
rhythmic waveforms to data, due to the fact that spontaneous rhythms are
not time linked to specific events making it difficult to align recorded
data and simulated results. However, a direct comparison can be made
between time averaged recorded and simulated signals by comparing PSD
plots. To do so, you will need time-series of MEG data in a format that
HNN can read (more details on this are provided in the Viewing
Datatutorial). The S1_ongoing.txt file will be used in the following
example (note: S1_ongoing.txt is also provided with HNN in its
data/MEG_detection_data sub-folder). This file contains raw data source
localized to SI from the 1 second prestimulus period before a tactile
stimulus, during the tactile detection experiment described in the
“Getting Started” section above[1]. You will need to extract the
contents of the .zip file to access the text file within. The data was
collected at 600 Hz. (Note, when loading your own data, if it was not
collected at 600 Hz, you must first downsample to 600 Hz to run a
frequency analysis and view it in the HNN GUI.)</p>
<p>Once you have downloaded the example data, you can load it into HNN
by first starting HNN’s PSD Viewer from main GUI window (View&gt; View
PSD). From HNN’s PSD Viewer, click:</p>
<p>File &gt; Load Data File</p>
<p>Then select the data file from your local machine. HNN will calculate
the PSD from the time-series data and overlay it on the simulation PSD
for comparison.</p>
<p>Below is an example output using the S1_ongoing file provided above.
The viewer will display the average PSD across trials and also the
standard error (displayed as dotted lines). Figure 17</p>
<p>image 15</p>
<p>In this example, there is strong similarity in the shape and
amplitude of the PSD generated by the model (bottom white traces) and
the PSD from experimental MEG data (bottom violet traces).</p>
<p>You can also load data directly into the “HNN Spectrogram Viewer”. To
load a single trial example of spontaneous SI activity from data
provided, first start the HNN Spectrogram Viewer by clicking View
Spectrogramsfrom HNN’s View menu in then main GUI. Then, click:</p>
<p>File &gt; Load Data File</p>
<p>And load the file S1_ongoing.txt. Next, select Trial 32 (for example)
from the drop-down menu at the bottom of the viewer. You will see the
following display. Figure 18</p>
<p>image10</p>
<p>Notice that as shown in the “Getting Started” section above (Figure
1), this single trial example of spontaneous SI data exhibits
non-continuous brief alpha and beta events. Since these data are
spontaneous and non-time locked, it would be difficult to directly
compare to simulated data. Instead, we compare qualitative features
between data and simulation results, as in Figure 2 above. See also Step
6.4 below, where multiple trials of spontaneous SI data are simulated
and averaged, producing more continuous bands of alpha and beta
activity.</p>

</div><div class='markdown-cell'>
    <h2>5. Adjusting parameters</h2>
<p>Parameter adjustments will be key to developing and testing
hypotheses on the circuit origin of your own low-frequency rhythmic
data.</p>
<p>Here, we’ll walk through examples with “Rhythmic Proximal/Distal
Input” parameters to investigate how they impact the alpha and beta
rhythms described above. We encourage you to copy the code from the
previous excercises, and adjust the parameters as indicated. We end with
some suggested exercises for further exploration.</p>
<h3>5.1 Changing the strength (post-synaptic conductance) and synchrony
of the distal drive increases beta activity</h3>
<p>We described above (Step 3) that the timing of proximal and distal
inputs can lead to either alpha events (when the bursts arrive to the
local network out of phase) or beta events (when the bursts arrive in
phase).</p>
<p>We have also found that other factors that contribute to the
prevalence of beta activity are the strengthend synchrony of the distal
inputs; beta activity is increased with stronger and more synchronous
subthreshold drive, where the beta frequency is set by the duration of
the driving bursts (~50ms) (Jones et al. 2009; Sherman et al. 2016). The
strength is controlled by the postsynaptic conductance set in the
<code>weights_ampa</code> dictionary, and the synchrony is controlled by
the <code>burst_std</code> parameter.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # Your code here
    </code>
</div><div class='markdown-cell'>
    <h3>5.1.1 Exercise for further exploration</h3>
<p>Try changing the frequency of the rhythmic distal drive from 10 Hz to
20 Hz by setting <code>burst_rate</code>. Try other frequencies for the
proximal and distal rhythmic drive. How do the rhythms change? See how
changes in the Burst stdev effects the rhythms expressed.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # Your code here

    </code>
</div>
<div class='markdown-cell'>
    <h3>5.2 Increasing the strength (post-synaptic conductance) of the
distal drive further creates high frequency responses due to induced
spiking activity</h3>
<p>Recall that in the above simulations, the strength of the rhythmic
proximal and distal inputs were chosen so that the cells remained
subthreshold (no spiking). We will now demonstrate what happens if we
increase the strength of the inputs far enough to induce spikes. Instead
of simulating subthreshold alpha/beta events, we will see that the
dipole signals are dominated by higher-frequency events created by
spiking activity. We note that the produced waveforms of activity are,
to our knowledge, not typically observed in MEG or EEG data, supporting
the notion that alpha/beta rhythms are created through subthreshold
processes.</p>
<p>To test this, change the parameters for the bursty distal drive as
follows. First, change <code>burst_std</code> value back to 20 ms. Next,
increase the postsynaptic conductance weights of the AMPA synapses onto
the Layer 2/3 and Layer 5 pyramidal neurons from 6e-5
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">μ</mi><mi mathvariant="normal">S</mi></mrow><annotation encoding="application/x-tex">\mathrm{\mu S}</annotation></semantics></math>
to 40e-5
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">μ</mi><mi mathvariant="normal">S</mi></mrow><annotation encoding="application/x-tex">\mathrm{\mu S}</annotation></semantics></math>
(a big change that will provide enough current to cause the cells to
spike).</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # Your code here
    </code>
</div>
<div class='markdown-cell'>
    <p>Notice that the histogram profile of the distal input bursts are once
again wider corresponding to less synchronous input and comparable to
those shown in the example in Step 3. However, in this case the
postsynaptic conductance of these driving spike is significantly larger
(40e-5
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">μ</mi><mi mathvariant="normal">S</mi></mrow><annotation encoding="application/x-tex">\mathrm{\mu S}</annotation></semantics></math>).
This strong input induces spiking activity in the pyramidal neuron on
several cycles of the drive resulting in a sharp and rapidly oscillating
dipole waveform. The corresponding dipole spectrogram shows broadband
spiking from ~60-120 Hz. This type of activity is not typically seen in
EEG or MEG data, and hence unlikely to underlie macroscale
recordings.</p>
<p>We can verify the increase in high-frequency activity more directly
by viewing the simulation’s power spectral density (PSD) with the
<code>plot_psd()</code> function.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # Your code here
    </code>
</div>
<div class='markdown-cell'>
    <p>The PSD from the simulation shows broadband 60-120Hz high frequency
activity caused by neuronal spiking. We can verify that the neurons are
spiking by looking at the spiking raster plots. This is done with a
function associated with the <code>Network</code> object and can be run
using <code>net.cell_response.plot_spikes_raster()</code>.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # Your code here
    </code>
</div>
<div class='markdown-cell'>
    <p>Notice that highly synchronous neuronal spiking in each population
coincides with the high-frequency events seen in the waveform and
spectrogram. The waveform response is induced by the pyramidal neuron
spiking which creates rapid back-propagating action potentials and
repolarization of the dendrites.</p>
<p>Hypothesis testing: This simulation demonstrates that HNN can be used
to test the limits of physiological variables and to see how, as
parameters are varied, simulations results can be similar or dissimilarto experimental data.</p>
<h3>5.2.1 Exercise for further exploration</h3>
<p>View the contribution of Layer 2/3 and Layer 5 to the net current
dipole waveform and compare with the spiking activity in each
population. This can be done with
<code>plot_dipole(dpl, layer=&amp;#x27;L2&amp;#x27;)</code> or
<code>plot_dipole(dpl, layer=&amp;#x27;L5&amp;#x27;)</code>. How do each
contribute? Try also to change the proximal input parameters instead of
the distal input parameters.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # Your code here
    </code>
</div>
<div class='markdown-cell'>
    <h3>5.3 Increasing the delay between the proximal and distal inputs to
anti-phase (50 ms delay) creates continuous alpha oscillations without
beta activity</h3>
<p>We mentioned above that, in addition to parameters controlling the
strength and synchrony of the distal (or proximal) drive, the relative
timing of proximal and distal inputs is an important factor in
determining relative alpha and beta expression in the model. Here we
will demonstrate that out-of-phase, 10 Hz burst inputs can produce
continuous alpha activity without any beta events.</p>
<p>First, copy the parameters from Step 3.1. Next, in for the rhythmic
distal inputs, change <code>tstart</code> from 50 to 100 ms.</p>
<p>Note that both the proximal and distal input <code>burst_rate</code>
are set to 10 Hz (bursts of activity every ~100 ms). Since the proximal
input Start time mean is 50.0 ms and the the distal input Start time
mean is 100.0 ms, the input will, on average, arrive to the network a
1/2 cycle out of phase (i.e., in antiphase, every 50 ms).</p>
<p>Next, we will run the simulation to investigate the impact of this
parameter change.</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # Your code here
    </code>
</div>
<div class='markdown-cell'>
    <p>Notice that the histogram profile of the proximal and distal input
bursts are generally ½ cycle out-of-phase (antiphase). This rhythmic
alteration of proximal followed by distal drive induces alternating
subthreshold current flow up and down the pyramidal neuron dendrites to
create a continuous alpha oscillation in the current dipole waveform
that oscillates around 0 nAm. The period of the oscillation is set by
the duration of each burst (~50 ms, controlled in part by Burst stdev)
and the 50 ms delay between the inputs on each cycle (due to different
start times). The corresponding spectrogram shows continuous nearly pure
alpha activity. This type of strong alpha activity is similar to what
might be observed over occipital cortex during eyes closedconditions.</p>
<h3>5.3.1 Exercise for further exploration</h3>
<p>Try changing the delay between the proximal and distal drive by
varying amounts. What happens to the rhythm expressed?</p>
<p>Can you create a simulation where other frequencies are expressed?
How is it created? Are the cells spiking or subthreshold?</p>

</div>
<div class='code-cell'>
    <code class='language-python'>
        # Your code here
    </code>
</div><div class='markdown-cell'>
    <h2>6. Have fun exploring your own data!</h2>
<p>Follow steps 1-5 above using your data and parameter adjustments
based on your own hypotheses.</p>

</div>
<div class='markdown-cell'>
    

</div>
        <!-- footer area -->
        <!----------------->
        <div class="footer-area">
            <div class="previous-area" data-link="/website_redesign/content/06_alpha_beta/gui.html">
                <div class="previous-icon">
                    <svg class="svg-arrow" width="25" height="25" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path class="arrow-path" d="M15 5L9 12L15 19" />
                    </svg>
                </div>
                <div class="previous-text">
                    <p>Previous</p>
                    <a>6.1 GUI Tutorial of Alpha/Beta Rhythms</a>
                </div>
            </div>
            <div class="next-area" data-link="/website_redesign/content/07_gamma/gamma_in_gui.html">
                <div class="next-text">
                    <p>Next</p>
                    <a>7.1 GUI Tutorial of Gamma Rhythms</a>
                </div>
                <div class="next-icon">
                    <svg class="svg-arrow" width="25" height="25" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path class="arrow-path" d="M15 5L9 12L15 19" />
                    </svg>
                </div>
            </div>
        </div> <!-- close footer -->
    </div> <!-- close content -->
    </div> <!-- close content wrapper -->
</div> <!-- close main -->
<script>
    // ----------------------------------------
    // Manage footer
    // ----------------------------------------
    // This function will update the footer links when a page is loaded
    // locally so that naivagation remains functional without a server
    // Note: this solution is specific to MacOS
    document.addEventListener("DOMContentLoaded", function() {
        if (window.location.protocol === "file:") {
            // Get the current local directory path
            const currentDir = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));

            // Process both previous and next links
            document.querySelectorAll('.previous-area, .next-area').forEach(function(area) {
                const link = area.getAttribute('data-link');
                
                if (link && link.startsWith("/")) {
                    // Extract the local root directory
                    const rootPath = currentDir.split("/website_redesign/")[0];
                    // Prepend root path to link
                    const resolvedLink = "file://" + rootPath + link;
                    area.setAttribute("data-link", resolvedLink);
                }
            });
        }
    });
    // Hide the area if data-link is 'None'
    document.querySelectorAll('.previous-area, .next-area').forEach(function(area) {
        if (area.getAttribute('data-link') === 'None') {
            area.style.display = 'none'; 
        }
    });

    // Redirect to the specified link
    document.querySelectorAll('.previous-area, .next-area').forEach(function(area) {
        area.addEventListener('click', function() {
            window.location.href = area.getAttribute('data-link');
        });
    });

    // ----------------------------------------
    // Manage sidebar
    // ----------------------------------------
    let isSidebarOpen = true; // Sidebar is initially open
    let isSidebarFullyOpen = true; // Sidebar is fully open
    const maxWidth = '350px';

    function toggleNav() {
        const sidebar = document.getElementById("mySidebar");
        const main = document.getElementById("main");

        // Toggle sidebar state
        if (isSidebarOpen) {
            sidebar.style.width = "0";
            main.style.marginLeft = "0";
            isSidebarFullyOpen = false;
        } else {
            sidebar.style.width = maxWidth;
            main.style.marginLeft = maxWidth;  // Match margin to new width
        }

        // Toggle the sidebar state
        isSidebarOpen = !isSidebarOpen;
    }

    // Always listen for the transitionend on the sidebar
    const sidebar = document.getElementById("mySidebar");
    sidebar.addEventListener('transitionend', function() {
        if (sidebar.style.width === maxWidth) {
            // Sidebar has fully opened
            isSidebarFullyOpen = true;
        } else {
            // Sidebar is not fully open
            isSidebarFullyOpen = false;
        }
    });

    // Open the sidebar on page load
    // -----------------------------
    window.onload = function() {
        // Set initial styles for open state without animation
        const sidebar = document.getElementById("mySidebar");
        const main = document.getElementById("main");

        sidebar.style.transition = "none";
        main.style.transition = "none";
        sidebar.style.width = maxWidth;
        main.style.marginLeft = maxWidth;

        // Re-enable transition for subsequent toggles
        setTimeout(() => {
            sidebar.style.transition = "width 0.5s";
            main.style.transition = "margin-left 0.5s";
        }, 10);
    }

    function toggleSubmenu(event) {
        const header = event.target.closest('#sidebar-header'); // Get the clicked header
        const submenu = header.nextElementSibling; // Get the submenu
        const toggleIcon = header.querySelector('.toggle-icon'); // Get the icon

        if (submenu && submenu.classList.contains('submenu')) {
            submenu.classList.toggle('open'); // Toggle the 'open' class to control visibility
            toggleIcon.textContent = submenu.classList.contains('open') ? '-' : '+'; // Update icon
        }
    }

    // Resolve sidebar links for local development
    // -------------------------------------------
    // This function will update the sidebar links when a page is loaded
    // locally so that sidebar naivagation remains functional without a server
    // Note: this solution is specific to MacOS
    document.addEventListener("DOMContentLoaded", function() {
        if (window.location.protocol === "file:") {
            // get the current local directory path
            const currentDir = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));

            // get 'absolute' links with root of 'website_redesign'
            const links = document.querySelectorAll("#mySidebar a");
            links.forEach(link => {
                const href = link.getAttribute("href");

                if (href && href.startsWith("/")) {
                    // extract the local root directory
                    const rootPath = currentDir.split("/website_redesign/")[0];
                    // prepend root path to link
                    const resolvedHref = "file://" + rootPath + href;
                    link.setAttribute("href", resolvedHref);
                }
            });

            // Update image sources for icons
            const images = document.querySelectorAll(".social-icons img, .menu-icons img");
            images.forEach(img => {
                const src = img.getAttribute("src");

                if (src && src.startsWith("/")) {
                    // extract the local root directory
                    const rootPath = currentDir.split("/website_redesign/")[0];
                    // prepend root path to image source
                    const resolvedSrc = "file://" + rootPath + src;
                    img.setAttribute("src", resolvedSrc);
                }
            });
        }
    });

    // Custom tooltips for the sidebar
    // -------------------------------
    // Flag to track tooltip visibility
    let isTooltipVisible = false;

    // Add text to the 'sidebar-tooltip' attribute for sidebar anchor tags
    document.querySelectorAll('.sidebar a').forEach(anchor => {
        const cleanedText = anchor.textContent.replace(/[+\-]/g, '').trim();
        anchor.setAttribute('sidebar-tooltip', cleanedText);
    });

    // Handle sidebar tooltips
    document.querySelectorAll('.sidebar a').forEach(function(link) {
        link.addEventListener('mouseenter', function(event) {
            const tooltipText = event.target.getAttribute('sidebar-tooltip');
            
            if (!tooltipText || isTooltipVisible || !isSidebarFullyOpen) return; // Only show tooltip if none is visible

            // Check if the text is overflowing
            if (event.target.scrollWidth > event.target.offsetWidth) {
                const delay = 500; // Set the delay time (in ms), adjust as needed

                // Create the tooltip after the delay
                setTimeout(function() {
                    // Remove any existing tooltips
                    const existingTooltip = document.querySelector('.sidebar-tooltip');
                    if (existingTooltip) {
                        existingTooltip.remove();
                    }

                    // Create the tooltip element dynamically
                    const tooltip = document.createElement('div');
                    tooltip.classList.add('sidebar-tooltip');  // Use the existing class
                    tooltip.innerText = tooltipText;

                    // Append the tooltip to the sidebar container
                    const sidebarContainer = document.querySelector('.sidebar');
                    sidebarContainer.appendChild(tooltip);

                    // Get the position of the link and the sidebar container
                    const rect = event.target.getBoundingClientRect();
                    const sidebarRect = sidebarContainer.getBoundingClientRect();

                    // Position the tooltip relative to the sidebar container
                    tooltip.style.position = 'absolute';
                    tooltip.style.left = `${rect.left - sidebarRect.left + sidebarContainer.scrollLeft + 20}px`;
                    tooltip.style.top = `${rect.bottom - sidebarRect.top + sidebarContainer.scrollTop + 5}px`;

                    // Make sure the tooltip is visible
                    tooltip.style.opacity = '1';

                    // Set the flag to true indicating that the tooltip is visible
                    isTooltipVisible = true;
                }, delay); // Delay the tooltip creation
            }
        });

        link.addEventListener('mouseleave', function(event) {
            // Remove the tooltip when the mouse leaves
            const tooltip = document.querySelector('.sidebar-tooltip');
            if (tooltip) {
                tooltip.remove();
            }

            // Reset the flag to false when the tooltip is removed
            isTooltipVisible = false;
        });
    });

    // Close all open submenus in the sidebar
    // --------------------------------------
    document.addEventListener("DOMContentLoaded", function() {
        // Function to close all open submenus in the navbar
        function closeAllSubmenus() {
            const allSubmenus = document.querySelectorAll('.submenu.open'); // Select all open submenus
            allSubmenus.forEach(submenu => {
                submenu.classList.remove('open'); // Remove 'open' class to collapse
                const toggleIcon = submenu.previousElementSibling.querySelector('.toggle-icon');
                if (toggleIcon) {
                    toggleIcon.textContent = '+'; // Reset icon to '+'
                }
            });
        }

        // Add functionality to collapse button (SVG icon)
        const collapseIcon = document.querySelector('.collapse-icon');
        if (collapseIcon) {
            collapseIcon.addEventListener('click', function(event) {
                event.stopPropagation(); // Prevent event propagation to avoid unwanted behavior
                closeAllSubmenus(); // Close all open submenus when the icon is clicked
            });
        }
    });

    // Keep the current page open in the sidebar
    // -----------------------------------------
    document.addEventListener("DOMContentLoaded", function () {
        // Get the full path relative to the 'content' folder
        const currentPage = window.location.pathname.split("/content/")[1].split("?")[0];

        // Find the active link using the full path
        const activeLink = document.querySelector(`#mySidebar a[href$='${currentPage}']`);

        if (activeLink) {
            // Apply the active class
            activeLink.classList.add("active");
             // Find the closest submenu
            const submenu = activeLink.closest('.submenu');

            if (submenu) {
                // Keep the submenu open
                submenu.classList.add('open');
                const toggleIcon = submenu.previousElementSibling.querySelector('.toggle-icon');

                if (toggleIcon) {
                    // Ensure the toggle icon reflects the open state
                    toggleIcon.textContent = '-';
                }
            }
        }
    });

    // ------------------------------
    // Font size buttons and dropdown
    // ------------------------------
    function increaseFontSize() {
        event.stopPropagation();  // Prevent dropdown from closing
        const content = document.getElementById("content");
        const currentSize = window.getComputedStyle(content).fontSize;
        content.style.fontSize = (parseFloat(currentSize) + 2) + "px";
    }

    function decreaseFontSize() {
        event.stopPropagation();  // Prevent dropdown from closing
        const content = document.getElementById("content");
        const currentSize = window.getComputedStyle(content).fontSize;
        content.style.fontSize = (parseFloat(currentSize) - 2) + "px";
    }

    // Dropdown for font buttons
    function toggleDropdown() {
        const dropdownContent = document.querySelector('.dropdown-content');
        dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
    }

    // Open/close dropdown on click of the button
    document.getElementById('dropdownButton').onclick = function(event) {
        event.stopPropagation();  // Prevent the click from triggering the window.onclick event
        toggleDropdown();
    };

    // Close dropdown if clicking outside
    window.onclick = function(event) {
        const dropdownContent = document.querySelector('.dropdown-content');
        if (!event.target.closest('.dropdown')) {  // Close if click outside the dropdown
            dropdownContent.style.display = 'none';
        }
    };

    // ----------------------------------------
    // Toggle between light and dark themes
    // ----------------------------------------
    // Wait for the DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', () => {
        const themeToggle = document.querySelector('.theme-toggle');
        const sidebar = document.querySelector('.sidebar');
        const sunSVG = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                <path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
            </svg>
        `;
        const moonSVG = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
                <path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
            </svg>
        `;

        // Check the saved theme preference
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            document.body.classList.toggle('dark-mode', savedTheme === 'dark');
            themeToggle.innerHTML = savedTheme === 'dark' ? moonSVG : sunSVG;
            sidebar.classList.toggle('dark-mode', savedTheme === 'dark');
        } else {
            // Default to light theme if no saved preference
            themeToggle.innerHTML = sunSVG;
        }

        // Add click event to toggle theme
        themeToggle.addEventListener('click', () => {
            const isDarkMode = document.body.classList.toggle('dark-mode');
            themeToggle.innerHTML = isDarkMode ? moonSVG : sunSVG;
            sidebar.classList.toggle('dark-mode', isDarkMode);
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
        });
    });

</script>

<!------------------------ #
# Code syntax highlighting #
# ------------------------->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />

<script>
    // Remove the leading whitespace/newlines around code blocks 
    // caused by the html structure used for readability
    document.addEventListener("DOMContentLoaded", function() {
        // Select all code blocks
        const codeBlocks = document.querySelectorAll('.code-cell code.language-python');

        codeBlocks.forEach(function(block) {
            // Apply syntax highlighting to the code block
            // Note: The below line is not needed with this setup
            //  but may be useful in the case that the method
            //  is later changed
            // Prism.highlightElement(block);

            // Get the code with highlighted classes
            const highlightedHTML = block.innerHTML;

            // Remove leading/trailing whitespace/newlines
            block.innerHTML = highlightedHTML.trim();
        });

        // Select all output-code blocks
        const outputBlocks = document.querySelectorAll('.output-cell .output-code');

        outputBlocks.forEach(function(block) {
            // Remove unwanted leading/trailing whitespace or newlines
            block.textContent = block.textContent.trim();
        });
    });

</script>

</body>
</html>