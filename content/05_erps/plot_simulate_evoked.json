{
    "full_executed": true,
    "plot_simulate_evoked.ipynb": {
        "5.2 API Tutorial of Event Related Potentials (ERPs) Simulation": {
            "level": 1,
            "html": "<div class='markdown-cell'>\n    <h1>5.2 API Tutorial of Event Related Potentials (ERPs) Simulation</h1>\n\n</div>\n<div class='markdown-cell'>\n    <p>This example demonstrates how to simulate a threshold level tactile\nevoked response, as detailed in the <a href=\"\">HNN GUI ERP tutorial</a>,\nusing HNN-core. We recommend you first review the GUI tutorial.</p>\n<p>The workflow below recreates an example of the threshold level\ntactile evoked response, as observed in Jones et al.\u00a0J. Neuroscience\n2007 [1], albeit without a direct comparison to the recorded data.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Authors: Mainak Jas <mmjas@mgh.harvard.edu>\n#          Sam Neymotin <samnemo@gmail.com>\n#          Blake Caldwell <blake_caldwell@brown.edu>\n#          Christopher Bailey <cjb@cfin.au.dk>\n\nimport os.path as op\nimport tempfile\n\nimport matplotlib.pyplot as plt \n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Let us import hnn_core</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        import hnn_core\nfrom hnn_core import simulate_dipole, jones_2009_model\nfrom hnn_core.viz import plot_dipole\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Let us first create our default network and visualize the cells\ninside it.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        net = jones_2009_model()\nnet.plot_cells()\nnet.cell_types['L5_pyramidal'].plot_morphology();\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        &lt;Figure size 640x480 with 1 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_plot_simulate_evoked/fig_01.png'/>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        &lt;Figure size 640x480 with 1 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_plot_simulate_evoked/fig_02.png'/>\n</div>\n<div class='markdown-cell'>\n    <p>The network of cells is now defined, to which we add external drives\nas required. Weights are prescribed separately for AMPA and NMDA\nreceptors (receptors that are not used can be omitted or set to zero).\nThe possible drive types include the following:</p>\n<ul>\n<li><code>hnn_core.Network.add_evoked_drive</code></li>\n<li><code>hnn_core.Network.add_poisson_drive</code></li>\n<li><code>hnn_core.Network.add_bursty_drive</code></li>\n</ul>\n\n</div>\n<div class='markdown-cell'>\n    <p>First, we add a distal evoked drive</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        weights_ampa_d1 = {\n    'L2_basket': 0.006562,\n    'L2_pyramidal': .000007,\n    'L5_pyramidal': 0.142300\n}\nweights_nmda_d1 = {\n    'L2_basket': 0.019482,\n    'L2_pyramidal': 0.004317,\n    'L5_pyramidal': 0.080074\n}\nsynaptic_delays_d1 = {\n    'L2_basket': 0.1,\n    'L2_pyramidal': 0.1,\n    'L5_pyramidal': 0.1\n}\n\nnet.add_evoked_drive(\n    'evdist1',\n    mu=63.53,\n    sigma=3.85,\n    numspikes=1,\n    weights_ampa=weights_ampa_d1,\n    weights_nmda=weights_nmda_d1,\n    location='distal',\n    synaptic_delays=synaptic_delays_d1,\n    event_seed=274\n)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Then, we add two proximal drives</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        weights_ampa_p1 = {\n    'L2_basket': 0.08831,\n    'L2_pyramidal': 0.01525,\n    'L5_basket': 0.19934,\n    'L5_pyramidal': 0.00865\n    }\nsynaptic_delays_prox = {\n    'L2_basket': 0.1,\n    'L2_pyramidal': 0.1,\n    'L5_basket': 1.,\n    'L5_pyramidal': 1.\n    }\n\n# all NMDA weights are zero; pass None explicitly\nnet.add_evoked_drive(\n    'evprox1',\n    mu=26.61,\n    sigma=2.47,\n    numspikes=1,\n    weights_ampa=weights_ampa_p1,\n    weights_nmda=None,\n    location='proximal',\n    synaptic_delays=synaptic_delays_prox,\n    event_seed=544\n)\n\n# Second proximal evoked drive. NB: only AMPA weights differ from first\nweights_ampa_p2 = {\n    'L2_basket': 0.000003,\n    'L2_pyramidal': 1.438840,\n    'L5_basket': 0.008958,\n    'L5_pyramidal': 0.684013\n    }\n\n# all NMDA weights are zero; omit weights_nmda (defaults to None)\nnet.add_evoked_drive(\n    'evprox2',\n    mu=137.12,\n    sigma=8.33,\n    numspikes=1,\n    weights_ampa=weights_ampa_p2,\n    location='proximal',\n    synaptic_delays=synaptic_delays_prox,\n    event_seed=814\n)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Now let's simulate the dipole, running 2 trials with the\n<code>hnn_core.parallel_backends.Joblib</code> backend. To run them in\nparallel we could set <code>n_jobs</code> to equal the number of trials.\nThe <code>Joblib</code> backend allows running the simulations in\nparallel across trials.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        from hnn_core import JoblibBackend\n\nwith JoblibBackend(n_jobs=2):\n    dpls = simulate_dipole(net, tstop=170., n_trials=2)\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Joblib will run 2 trial(s) in parallel by distributing trials over 2 jobs.\n\n        Loading custom mechanism files from /opt/homebrew/Caskroom/miniconda/base/envs/website-redesign/lib/python3.12/site-packages/hnn_core/mod/arm64/.libs/libnrnmech.so\nBuilding the NEURON model\nLoading custom mechanism files from /opt/homebrew/Caskroom/miniconda/base/envs/website-redesign/lib/python3.12/site-packages/hnn_core/mod/arm64/.libs/libnrnmech.so\nBuilding the NEURON model\n[Done]\n[Done]\nTrial 1: 0.03 ms...\nTrial 2: 0.03 ms...\nTrial 1: 10.0 ms...\nTrial 2: 10.0 ms...\nTrial 1: 20.0 ms...\nTrial 2: 20.0 ms...\nTrial 1: 30.0 ms...\nTrial 2: 30.0 ms...\nTrial 1: 40.0 ms...\nTrial 2: 40.0 ms...\nTrial 1: 50.0 ms...\nTrial 2: 50.0 ms...\nTrial 1: 60.0 ms...\nTrial 2: 60.0 ms...\nTrial 1: 70.0 ms...\nTrial 2: 70.0 ms...\nTrial 1: 80.0 ms...\nTrial 2: 80.0 ms...\nTrial 1: 90.0 ms...\nTrial 2: 90.0 ms...\nTrial 1: 100.0 ms...\nTrial 2: 100.0 ms...\nTrial 1: 110.0 ms...\nTrial 2: 110.0 ms...\nTrial 1: 120.0 ms...\nTrial 2: 120.0 ms...\nTrial 1: 130.0 ms...\nTrial 2: 130.0 ms...\nTrial 1: 140.0 ms...\nTrial 2: 140.0 ms...\nTrial 1: 150.0 ms...\nTrial 2: 150.0 ms...\nTrial 1: 160.0 ms...\nTrial 2: 160.0 ms...\n\n    </div>\n</div>\n<div class='markdown-cell'>\n    <p>Rather than reading smoothing and scaling parameters from file, we\nrecommend explicit use of the\n<code>~hnn_core.dipole.Dipole.smooth</code> and\n<code>~hnn_core.dipole.Dipole.scale</code> methods instead. Note that\nboth methods operate in-place, i.e., the objects are modified.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        window_len, scaling_factor = 30, 3000\nfor dpl in dpls:\n    dpl.smooth(window_len).scale(scaling_factor)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Plot the amplitudes of the simulated aggregate dipole moments over\ntime</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        import matplotlib.pyplot as plt\nfig, axes = plt.subplots(\n    2,\n    1, \n    sharex=True,\n    figsize=(6, 6),\n    constrained_layout=True\n)\n\nplot_dipole(\n    dpls,\n    ax=axes[0],\n    layer='agg',\n    show=False\n)\n\nnet.cell_response.plot_spikes_hist(\n    ax=axes[1],\n    spike_types=['evprox', 'evdist']\n);\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        &lt;Figure size 600x600 with 2 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_plot_simulate_evoked/fig_03.png'/>\n</div>\n<div class='markdown-cell'>\n    <p>If you want to analyze how the different cortical layers contribute\nto different net waveform features, then instead of passing\n<code>agg</code> to <code>layer</code>, you can provide a list of layers\nto be visualized and optionally a list of axes to <code>ax</code> to\nvisualize the dipole moments separately.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        plot_dipole(\n    dpls,\n    average=False,\n    layer=['L2', 'L5', 'agg'],\n    show=False\n);\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        &lt;Figure size 640x480 with 3 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_plot_simulate_evoked/fig_04.png'/>\n</div>\n<div class='markdown-cell'>\n    <p>Now, let us try to make the exogenous driving inputs to the cells\nsynchronous and see what happens. This is achieved by setting\n<code>n_drive_cells=1</code> and <code>cell_specific=False</code> when\nadding each drive.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        net_sync = jones_2009_model()\n\nn_drive_cells=1\ncell_specific=False\n\nnet_sync.add_evoked_drive(\n    'evdist1',\n    mu=63.53,\n    sigma=3.85,\n    numspikes=1,\n    weights_ampa=weights_ampa_d1,\n    weights_nmda=weights_nmda_d1,\n    location='distal',\n    n_drive_cells=n_drive_cells,\n    cell_specific=cell_specific,\n    synaptic_delays=synaptic_delays_d1,\n    event_seed=274\n)\n\nnet_sync.add_evoked_drive(\n    'evprox1',\n    mu=26.61,\n    sigma=2.47,\n    numspikes=1,\n    weights_ampa=weights_ampa_p1,\n    weights_nmda=None,\n    location='proximal',\n    n_drive_cells=n_drive_cells,\n    cell_specific=cell_specific,\n    synaptic_delays=synaptic_delays_prox,\n    event_seed=544\n)\n\nnet_sync.add_evoked_drive(\n    'evprox2',\n    mu=137.12,\n    sigma=8.33,\n    numspikes=1,\n    weights_ampa=weights_ampa_p2,\n    location='proximal',\n    n_drive_cells=n_drive_cells,\n    cell_specific=cell_specific,\n    synaptic_delays=synaptic_delays_prox,\n    event_seed=814\n)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>You may interrogate current values defining the spike event time\ndynamics by</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        print(net_sync.external_drives['evdist1']['dynamics'])\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        {&#x27;mu&#x27;: 63.53, &#x27;sigma&#x27;: 3.85, &#x27;numspikes&#x27;: 1}\n\n    </div>\n</div>\n<div class='markdown-cell'>\n    <p>Finally, let's simulate this network. Rather than modifying the\ndipole object, this time we make a copy of it before smoothing and\nscaling.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        dpls_sync = simulate_dipole(\n    net_sync,\n    tstop=170.,\n    n_trials=1\n)\n\ntrial_idx = 0\n\ndpls_sync[trial_idx].copy().smooth(window_len).scale(scaling_factor).plot()\nnet_sync.cell_response.plot_spikes_hist();\n    </code>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        Joblib will run 1 trial(s) in parallel by distributing trials over 1 jobs.\nLoading custom mechanism files from /opt/homebrew/Caskroom/miniconda/base/envs/website-redesign/lib/python3.12/site-packages/hnn_core/mod/arm64/.libs/libnrnmech.so\nBuilding the NEURON model\n[Done]\nTrial 1: 0.03 ms...\nTrial 1: 10.0 ms...\nTrial 1: 20.0 ms...\nTrial 1: 30.0 ms...\nTrial 1: 40.0 ms...\nTrial 1: 50.0 ms...\nTrial 1: 60.0 ms...\nTrial 1: 70.0 ms...\nTrial 1: 80.0 ms...\nTrial 1: 90.0 ms...\nTrial 1: 100.0 ms...\nTrial 1: 110.0 ms...\nTrial 1: 120.0 ms...\nTrial 1: 130.0 ms...\nTrial 1: 140.0 ms...\nTrial 1: 150.0 ms...\nTrial 1: 160.0 ms...\n\n        &lt;Figure size 640x480 with 1 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_plot_simulate_evoked/fig_05.png'/>\n</div>\n<div class='output-cell'><div class='output-label'>\n    Out:\n</div>\n    <div class='output-code'>\n        &lt;Figure size 640x480 with 1 Axes&gt;\n    </div>\n</div>\n<div class='output-cell'>\n    <img src='output_nb_plot_simulate_evoked/fig_06.png'/>\n</div>"
        },
        "Warning": {
            "level": 4,
            "html": "<div class='markdown-cell'>\n    <h4>Warning</h4>\n<ul>\n<li><p>Always look at dipoles in conjunction with raster plots and spike\nhistogram to avoid misinterpretation.</p></li>\n<li><p>Run multiple trials of your simulation to get an average of\ndifferent drives seeds before drawing conclusions.</p></li>\n</ul>\n\n</div>"
        },
        "References": {
            "level": 2,
            "html": "<div class='markdown-cell'>\n    <h2>References</h2>\n<p>[1] Jones, Stephanie R., et al.\u00a0\"Neural correlates of tactile\ndetection: a combined magnetoencephalography and biophysically based\ncomputational modeling study.\" Journal of Neuroscience 27.40 (2007):\n10751-10764.</p>\n\n</div>"
        }
    }
}